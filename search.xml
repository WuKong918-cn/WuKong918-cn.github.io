<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BIO、NIO、AIO对比分析</title>
      <link href="/BIO%E3%80%81NIO%E3%80%81AIO%E5%88%86%E6%9E%90.html"/>
      <url>/BIO%E3%80%81NIO%E3%80%81AIO%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="常见的概念"><a href="#常见的概念" class="headerlink" title="常见的概念"></a>常见的概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java中BIO、NIO、AIO是Java语言对于操作系统各种IO模型的封装，程序能使用什么类型的IO取决于系统是否支持该种IO类型的操作。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul><li><p><code>同步</code>: 是发起一个调用后，<strong>被调用者未处理完成请求前，调用不会返回</strong>。</p></li><li><p><code>异步</code>: 是发起一个调用后，<strong>立刻得到被调用者回应</strong>表示已经接收到请求。但返回的并不是结果，这是调用者可以去处理其他的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。</p></li><li><p><code>区别</code>：<strong>同步需要调用者等待结果，而异步不需要调用者等待结果</strong>，被调用者会通过回调等机制来通知调用者其返回结果。</p></li><li><p><code>关注点</code>: 同步和异步关注的是<strong>消息通信机制</strong>。所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到<strong>结果</strong>之前，该<strong>调用</strong>就不返回。但是一旦<strong>调用返回，就得到返回值了</strong>。换句话说，就是由<strong>调用者</strong>主动等待这个调用的结果。</p></li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li><code>阻塞</code>: 发起一个请求，调用者会一直等待请求结果的返回，也就是当前线程会被挂起，无法从事其他任务，当条件就绪才能继续。</li><li><code>非阻塞</code>: 发起一个请求，<strong>立马返回结果</strong>，不用等待条件就绪才返回。</li><li><code>关注点</code>: 阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息、返回值）时的状态</strong>。阻塞调用是指调用结果返回之前，当前线程会被挂起，被调用程序只有在得到结果之后才会返回。非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li></ul><a id="more"></a><h2 id="生活例子"><a href="#生活例子" class="headerlink" title="生活例子"></a>生活例子</h2><p>你渴了，想要喝水，但是现在没水，需要先烧水。</p><ol><li>小时候你比较笨啊，在那里傻等着水开（<strong>同步阻塞</strong>）。</li><li>等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（<strong>同步非阻塞</strong>）。</li><li>后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（<strong>异步非阻塞</strong>）。</li></ol><p>这个例子中<code>是否水开</code>就是调用程序返回值。</p><ul><li>在事件1中，水不开你不走，一直傻等到水开了（<strong>阻塞等待</strong>），才能喝到水（<strong>执行程序逻辑</strong>）。从<strong>消息通信机制</strong>上来讲是<strong>同步</strong>的，因为<strong>“烧水”</strong>这个方法返回的是<strong>“是否水开”</strong>，只是说<strong>阻塞等待直到水开了才会返回。</strong></li><li>在事件2中，你学聪明了，知道时不时的去检查下水烧开没（<strong>非阻塞，立刻得到结果</strong>），如果没烧开还能在聊天群里划划水（<strong>干点其他零散的小事，反正程序不能闲着</strong>），烧开了才能喝到水（<strong>执行程序逻辑</strong>）。从<strong>消息通信机制</strong>上来讲是<strong>同步</strong>的，因为<strong>“检查烧水”</strong>这个方法返回的是<strong>“是否水开”</strong>，只是说<strong>非阻塞每次立马返回水是否烧开的状态。</strong></li><li>在事件3中，用上了烧开了会发出声音的水壶（<strong>回调机制</strong>），把水壶放在火炉上烧着（<strong>通知被调用者</strong>），在水壶没发声之前可以写一部分技术分享内容（<strong>让被调用者异步执行，调用者去做其他事</strong>），水壶响了（<strong>被调用者执行完成，通知调用者</strong>），喝水（<strong>执行程序逻辑</strong>）。从<strong>消息通信机制</strong>上来讲是<strong>异步</strong>的，只需要去操作下火炉，让火炉烧水即可，<strong>“操作火炉烧水”</strong>这个方法返回的不是我们期待的<strong>“水是否烧开”</strong>的返回值，而是火炉已经开始烧水的状态返回值（<strong>被调用者返回已经接收到消息</strong>）。当<strong>“水壶响了”</strong>这个回调方法执行后，我们也立刻获得<strong>“水开了”</strong>的返回值（<strong>非阻塞</strong>）。</li></ul><h1 id="BIO（Blocking-I-O）"><a href="#BIO（Blocking-I-O）" class="headerlink" title="BIO（Blocking I/O）"></a>BIO（Blocking I/O）</h1><p>同步阻塞I/O（Blocking Input/Output）模式，数据读取写入必须阻塞在一个线程内等待其完成。</p><h2 id="传统BIO"><a href="#传统BIO" class="headerlink" title="传统BIO"></a>传统BIO</h2><p>采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接。</p><p>以下图为网上查找图片：</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20210502150323.png" alt="BIO通信模型图"></p><p>对应demo的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, Socket&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//对应客户端号和服务端号</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = ++num;</span><br><span class="line">            <span class="comment">//接收连接</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">//循环创建线程来处理对应的连接</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(no, socket);</span><br><span class="line">                System.out.printf(<span class="string">"服务「%d」开始服务%n"</span>, no);</span><br><span class="line">                <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                     PrintWriter writer = <span class="keyword">new</span> PrintWriter(socket.getOutputStream())) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//读数据</span></span><br><span class="line">                    String line;</span><br><span class="line">                  <span class="comment">//如果读不到消息会在reader.readLine()阻塞</span></span><br><span class="line">                    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.printf(<span class="string">"服务「%d」接收到消息:%s%n"</span>, no, line);</span><br><span class="line">                        <span class="comment">//写数据</span></span><br><span class="line">                        sendGroupMsg(no, line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromNo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendGroupMsg</span><span class="params">(<span class="keyword">int</span> fromNo, String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer no : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">//不发送，发送者消息</span></span><br><span class="line">            <span class="keyword">if</span> (no.equals(fromNo)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Socket socket = map.get(no);</span><br><span class="line">            PrintWriter writer = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">            writer.println(String.format(<span class="string">"「%d」客户端发来消息:%s"</span>, fromNo, msg));</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NIO（New-I-O）"><a href="#NIO（New-I-O）" class="headerlink" title="NIO（New I/O）"></a>NIO（New I/O）</h1><p>NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。<br>它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 <strong>SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</strong>阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</p><ol><li><p>对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性。</p></li><li><p>对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p></li></ol><h2 id="NIO的特性，NIO和BIO区别"><a href="#NIO的特性，NIO和BIO区别" class="headerlink" title="NIO的特性，NIO和BIO区别"></a>NIO的特性，NIO和BIO区别</h2><p>如果回答这个问题，<font color="red">我觉得首先肯定要从 NIO 流是非阻塞 IO 而 BIO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。</font>这些都懂了之后，对 NIO 就有了更为深入一点的认识。</p><h3 id="1）Non-bloking-IO（非阻塞IO）"><a href="#1）Non-bloking-IO（非阻塞IO）" class="headerlink" title="1）Non-bloking IO（非阻塞IO）"></a>1）Non-bloking IO（非阻塞IO）</h3><p><strong>BIO流是阻塞的，NIO流是不阻塞的。</strong><br>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，若系统底层读缓冲区没有数据也会立刻返回，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的，若系统底层写缓冲区无法写入数据时也会立刻返回。所以在实际代码中应该增加判断是否写入完成，或读取完成。以下为模拟系统底层写缓冲区满了之后无法写入的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">//创建客户端socket通道 &amp; 连接host:port</span></span><br><span class="line">       SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>));</span><br><span class="line">       <span class="comment">//设置为非阻塞模式，可以注释后对比阻塞和非阻塞的输出</span></span><br><span class="line">       socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">//非阻塞的形式连接服务器，如果直接使用open带参数的，连接的时候是阻塞连接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//传入消息 1mb 1024 * 1024 = 1048576</span></span><br><span class="line">       <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">       ByteBuffer wrap = ByteBuffer.wrap(bytes);</span><br><span class="line">       <span class="comment">//循环一万次</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> write = socketChannel.write(wrap);</span><br><span class="line">           <span class="comment">//输出写入长度</span></span><br><span class="line">           System.out.println(write);</span><br><span class="line">           <span class="keyword">if</span> (!wrap.hasRemaining()) &#123;</span><br><span class="line">               <span class="comment">//写完了 继续重新写</span></span><br><span class="line">               wrap.flip();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//还有剩余没写完不操作ByteBuffer，继续写剩下的</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Java IO的各种流是阻塞的。这意味着，<strong>当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。</strong>该线程在此期间线程是挂起的不能再干任何事情了。</p><h3 id="2）Buffer（缓冲区）"><a href="#2）Buffer（缓冲区）" class="headerlink" title="2）Buffer（缓冲区）"></a>2）Buffer（缓冲区）</h3><p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p><ul><li>NIO类库加入Buffer对象，即所有数据都是用缓冲区处理的，在读取数据时，它是直接读到缓冲区中，在写入数据时，写到缓冲区中。任何时间访问NIO中的数据，都是通过缓冲区进行操作。</li><li>最常用的缓冲区是ByteBuffer，一个ByteBuffer用于操作byte数组。每一种Java基本类型都对应一种缓冲区（除了boolean类型）。</li><li>需要注意一点，在NIO写中使用ByteBuffer时程序都会转换为DirectByteBuffer（使用直接内存Buffer）然后再写到远端。</li></ul><h4 id="Buffer中重要概念"><a href="#Buffer中重要概念" class="headerlink" title="Buffer中重要概念"></a>Buffer中重要概念</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line"><span class="comment">//....一堆代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">  <span class="comment">//标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//标记是一个索引，通过 Buffer 中的 mark() 方法</span></span><br><span class="line">  <span class="comment">//指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制(limit)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一个不应该读取或写入的数据的索引，即位于 limit 后的数据</span></span><br><span class="line"><span class="comment">//不可读写。缓冲区的限制不能为负，并且不能大于其容量。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="comment">//表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//... 一堆代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20210502172437.png" alt="Buffer缓冲区"></p><h4 id="Buffer常用方法"><a href="#Buffer常用方法" class="headerlink" title="Buffer常用方法"></a>Buffer常用方法</h4><ul><li>Buffer clear()    清空缓冲区（不会清空实际存储的数据）并返回对缓冲区的引用</li><li>Buffer flip()    将缓冲区的界限设置为当前位置，并将当前位置充值为 0</li><li>int capacity()    返回 Buffer 的 capacity 大小</li><li>boolean hasRemaining()    判断缓冲区中是否还有元素</li><li>int limit()    返回 Buffer 的界限(limit) 的位置</li><li>Buffer limit(int n)    将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</li><li>Buffer mark()    对缓冲区设置标记</li><li>int position()    返回缓冲区的当前位置 position</li><li>Buffer position(int n)    将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象</li><li>int remaining()    返回 position 和 limit 之间的元素个数</li><li>Buffer reset()    将位置 position 转到以前设置的 mark 所在的位置</li><li>Buffer rewind()    将位置设为 0， 取消设置的 mark</li></ul><h4 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h4><p>字节缓冲区要么是<strong>直接</strong>的，要么是<strong>非直接</strong>的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</p><p>直接字节缓冲区可以通过调用此类的 <strong>allocateDirect()</strong> 工厂方法来创建。此方法<strong>返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区</strong>。直接缓冲区的内容<strong>可以驻留在常规的垃圾回收堆</strong>之外，因此，它们对<strong>应用程序的内存需求量</strong>造成的影响可能<strong>并不明显</strong>。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，<strong>最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们</strong>。</p><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</p><p>以下图为网上查找图片：</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20210502173610.png" alt="非直接缓冲区"></p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20210502193626.png" alt="直接缓冲区"></p><h4 id="JVM开辟的堆外内存如何回收？"><a href="#JVM开辟的堆外内存如何回收？" class="headerlink" title="JVM开辟的堆外内存如何回收？"></a>JVM开辟的堆外内存如何回收？</h4><p>我们都知道JVM自带了垃圾回收器可以回收堆里的对象，垃圾回收器又是基于可达性算法来查找需要回收的对象。</p><p>但是堆外内存（直接内存）DirectByteBuffer是如何进行管理的呢？</p><p>首先我们确定一点，DirectByteBuffer是JDK提供的代理处理直接内存的类，若我们没有使用DirectByteBuffer对象了，该对象被垃圾回收后是如何处理的？</p><p>我们先来看看DirectByteBuffer的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"><span class="comment">//私有构造器，我们无法直接构造该对象</span></span><br><span class="line">  DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"><span class="comment">//super为MappedByteBuffer。MappedByteBuffer的super为ByteBuffer</span></span><br><span class="line">    <span class="comment">//cap,开辟的空间大小</span></span><br><span class="line">      <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="comment">//是否直接内存页面对其，这里略过</span></span><br><span class="line">      <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">      <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="comment">//根据算法计算开辟出来的大小</span></span><br><span class="line">      <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">      Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用unsafe来开辟直接内存</span></span><br><span class="line">          base = unsafe.allocateMemory(size);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">//开辟失败 超出剩余内存,</span></span><br><span class="line">          Bits.unreserveMemory(size, cap);</span><br><span class="line">          <span class="keyword">throw</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">      unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="comment">// Round up to page boundary</span></span><br><span class="line">          address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          address = base;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建清理器</span></span><br><span class="line">      cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">      att = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看出，DirectByteBuffer是使用unsafe来开辟内存空间的。而释放直接内存我们应该看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br></pre></td></tr></table></figure><p>这里有两个参数，一个是<code>DirectByteBuffer本身</code>，另一个是<code>new Deallocator(base, size, cap)</code>。</p><p>查阅Deallocator源码可知道，释放内存是调用了<code>unsafe.freeMemory(address);</code>方法来释放管理的直接内存的。</p><p>到这里可能很多人就会想什么情况下会调用<code>Cleaner中的Deallocator</code>呢？因为这里涉及到JDK提供的引用基础知识（强、软、弱、虚，引用队列、垃圾回收对各种引用的影响）这里就略过，有需要的读者<code>自行上网查阅相关引用的资料</code>。</p><p>Cleaner中有如下一块代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//this.trunk实际就是我们之前传入的Deallocator对象</span></span><br><span class="line">                <span class="keyword">this</span>.thunk.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            (<span class="keyword">new</span> Error(<span class="string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现Cleaner.clean()是可以释放直接内存的，查看Cleaner.clean()的调用点跳转到Reference引用类中，包含如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* High-priority thread to enqueue pending References</span></span><br><span class="line"><span class="comment"> * 最高优先级的线程，来操作“待办的引用”（被垃圾回收的引用）放入引用队列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">//预加载类初始化</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Class.forName(clazz.getName(), <span class="keyword">true</span>, clazz.getClassLoader());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> (Error) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          <span class="comment">// pre-load and initialize InterruptedException and Cleaner classes</span></span><br><span class="line">        <span class="comment">// 预加载并初始化InterruptedException和Cleaner类</span></span><br><span class="line">          <span class="comment">// so that we don't get into trouble later in the run loop if there's</span></span><br><span class="line">        <span class="comment">// 这样我们就不会在运行循环中遇到麻烦</span></span><br><span class="line">          <span class="comment">// memory shortage while loading/initializing them lazily.</span></span><br><span class="line">          <span class="comment">// 延迟加载/初始化它们时内存不足。</span></span><br><span class="line">          ensureClassInitialized(InterruptedException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">          ensureClassInitialized(Cleaner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">          <span class="keyword">super</span>(g, name);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//执行的方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//死循环，执行处理待办的引用</span></span><br><span class="line">              tryHandlePending(<span class="keyword">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Try handle pending &#123;<span class="doctag">@link</span> Reference&#125; if there is one.&lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Return &#123;<span class="doctag">@code</span> true&#125; as a hint that there might be another</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> Reference&#125; pending or &#123;<span class="doctag">@code</span> false&#125; when there are no more pending</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> Reference&#125;s at the moment and the program can do some other</span></span><br><span class="line"><span class="comment">   * useful work instead of looping.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> waitForNotify if &#123;<span class="doctag">@code</span> true&#125; and there was no pending</span></span><br><span class="line"><span class="comment">   *                      &#123;<span class="doctag">@link</span> Reference&#125;, wait until notified from VM</span></span><br><span class="line"><span class="comment">   *                      or interrupted; if &#123;<span class="doctag">@code</span> false&#125;, return immediately</span></span><br><span class="line"><span class="comment">   *                      when there is no pending &#123;<span class="doctag">@link</span> Reference&#125;.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there was a &#123;<span class="doctag">@link</span> Reference&#125; pending and it</span></span><br><span class="line"><span class="comment">   *         was processed, or we waited for notification and either got it</span></span><br><span class="line"><span class="comment">   *         or thread was interrupted before being notified;</span></span><br><span class="line"><span class="comment">   *         &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">      Reference&lt;Object&gt; r;</span><br><span class="line">      Cleaner c;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">          <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">//待办的引用队列，此队列由JVM垃圾回收器放入引用对象</span></span><br><span class="line">              <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//pending为Reference</span></span><br><span class="line">                  r = pending;</span><br><span class="line">                  <span class="comment">// 'instanceof' might throw OutOfMemoryError sometimes</span></span><br><span class="line">                <span class="comment">// 'instanceof'有时可能会抛出OutOfMemoryError</span></span><br><span class="line">                  <span class="comment">// so do this before un-linking 'r' from the 'pending' chain...</span></span><br><span class="line">                <span class="comment">// 因此，请先取消链接“待定”链中的“ r”，然后再执行此操作...</span></span><br><span class="line">                  c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// unlink 'r' from 'pending' chain</span></span><br><span class="line">                <span class="comment">// 从pending链中取消链接r</span></span><br><span class="line">                <span class="comment">// discovered代表r中下一个待办的引用</span></span><br><span class="line">                  pending = r.discovered;</span><br><span class="line">                <span class="comment">// 切断链接</span></span><br><span class="line">                  r.discovered = <span class="keyword">null</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                  <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                <span class="comment">// waitForNotify默认传的true，JVM不可能让这个操作不停的占用CPU吧～</span></span><br><span class="line">                  <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    <span class="comment">//让当前线程挂起等待，直到被notify或notifyAll</span></span><br><span class="line">                    <span class="comment">//notify的是JVM的垃圾回收器，当在往pending赋值后唤醒</span></span><br><span class="line">                      lock.wait();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// retry if waited</span></span><br><span class="line">                  <span class="keyword">return</span> waitForNotify;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">          <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">          <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">          <span class="comment">// Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above</span></span><br><span class="line">          <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">          Thread.yield();</span><br><span class="line">          <span class="comment">// retry</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">          <span class="comment">// retry</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Fast path for cleaners</span></span><br><span class="line">    <span class="comment">// 说明被回收的是Cleaner对象</span></span><br><span class="line">      <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用clean方法</span></span><br><span class="line">          c.clean();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//获取引用对应的引用队列</span></span><br><span class="line">      ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="comment">//如果该引用设置了引用队列，将已经被垃圾回收的引用入队</span></span><br><span class="line">      <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">      <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">           tgn != <span class="keyword">null</span>;</span><br><span class="line">           tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="comment">//创建引用处理对象</span></span><br><span class="line">      Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">      <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">       * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="comment">//设置最高的优先级</span></span><br><span class="line">      handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    <span class="comment">//守护线程，守护的JVM主线程，当我们主线程退出了，这个守护线程也退出</span></span><br><span class="line">      handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//开启线程</span></span><br><span class="line">      handler.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">      SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryHandlePendingReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> tryHandlePending(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>至此因该会明白对堆外内存的回收，DirectByteBuffer提供了Cleaner的对象属性。</p><ol><li>当DirectByteBuffer被垃圾回收时，Cleaner这个虚引用对象也会被垃圾回收（注意：这个Cleaner对象是个强引用噢，只是说Cleaner.get()无论何时都为null）。</li><li>当Cleaner被垃圾回收时代表，该Cleaner对象已经被JVM垃圾回收器放入了Reference中的pending单项链表中了。</li><li>此时若ReferenceHandler线程正在挂起，就唤醒他。</li><li>唤醒了ReferenceHandler后，会调用Cleaner.clean()方法</li><li>Cleaner.clean()会调用<code>this.thunk.run();</code>，其中this.thunk为DirectByteBuffer中创建的new Deallocator(base, size, cap)</li><li>Deallocator对象的run方法中调用了<code>unsafe.freeMemory(address);</code>来释放DirectByteBuffer所代理的直接内存</li></ol><p>在以上流程中可以发现释放直接内存是使用的<strong>JVM提供的垃圾回收</strong>触发的<strong>ReferenceHandler守护线程中的钩子函数</strong>来完成的。</p><p>所以在实际使用中我们无需手动去管理DirectByteBuffer对直接内存的释放，但是需要注意一点<font color="red">垃圾回收是不可控的，可能挺长一段时间才回收一次，如果并发量很大我们同时开辟了多个直接内存，很有可能造成内存溢出</font>，所以我们自己使用的时候要小心一点，一定要在使用完成后调用<code>directByteBuffer.cleaner().clean()</code>主动触发释放内存，而不要过度依赖垃圾回收提供的钩子函数。</p><p>还有就是在使用NIO的时候，write时最好使用DirectByteBuffer而不用ByteBuffer来构建，用来减少在write时将ByteBuffer复制到DirectByteBuffer中。使用完成后记得手动释放堆外内存。</p><h3 id="3）Channel（通道）"><a href="#3）Channel（通道）" class="headerlink" title="3）Channel（通道）"></a>3）Channel（通道）</h3><p><strong>NIO通过Channel（通道）进行读写。</strong></p><p>每个channel对应每个连接。</p><p>通道是<strong>双向的</strong>，可读可写，而流是单向。因为通道只能和Buffer交互，因为Buffer，通道可以异步的读写。</p><h3 id="4）Selectors（选择器）"><a href="#4）Selectors（选择器）" class="headerlink" title="4）Selectors（选择器）"></a>4）Selectors（选择器）</h3><p><strong>NIO有选择器，而IO没有。</strong><br>选择器是用于单个线程处理多个通道（多路复用）。多路复用是基于系统层面实现的。</p><h3 id="NIO核心组件"><a href="#NIO核心组件" class="headerlink" title="NIO核心组件"></a>NIO核心组件</h3><p>三个：</p><ul><li>Channel（通道）</li><li>Buffer（缓冲区）</li><li>Selector（选择器）</li></ul><p>NIO体系包含不止包含这三个类，这三个是核心。</p><h1 id="AIO（Asynchronous-I-O）"><a href="#AIO（Asynchronous-I-O）" class="headerlink" title="AIO（Asynchronous I/O）"></a>AIO（Asynchronous I/O）</h1><p>AIO是NIO2，即在java7中引入NIO的改进版NIO2，他是<strong>异步非阻塞的IO模型</strong>。异步IO是基于事件和回调实现。也就是引用操作之后会直接返回，不会阻塞等待，当后台处理完，操作系统会通知相应的线程进行后续的操作。<br><strong>除了AIO其他的IO类型都是同步的。</strong></p><p>AIO使用场景较少，可以百度一下编写的demo。在此就略过了。</p><h2 id="Netty底层使用NIO而不使用AIO"><a href="#Netty底层使用NIO而不使用AIO" class="headerlink" title="Netty底层使用NIO而不使用AIO"></a>Netty底层使用NIO而不使用AIO</h2><p>以下内容来源于网络</p><ol><li><p>NIO中将多路请求注册到多路复用器上，线程轮询请求状态，发现线程完毕则分配线程进行处理业务逻辑；而AIO是每个请求从一开始就分配一个线程，实现了真正的异步处理。但是这也会带来一个问题，线程池中线程的数量不是无限的，如果每个请求从一开始就分配线程进行处理，很快就会用完线程。</p></li><li><p>在Linux系统上，AIO的底层实现仍使用EPOLL，与NIO相同，因此在性能上没有明显的优势；Windows的AIO底层实现良好，但是Netty开发人员并没有把Windows作为主要使用平台考虑</p></li></ol><h1 id="学习展望"><a href="#学习展望" class="headerlink" title="学习展望"></a>学习展望</h1><ol><li>多路复用在系统层面是如何操作的</li><li>零拷贝是如何实现的</li></ol><p>这两块东西都是涉及到很多系统函数和硬件层面的知识，许多都是系统层面提供的函数，在linux和unix（MacOS）系统中可以通过man命令去了解这些函数的描述，网上也有很多man手册汉化的资源。若系统查询不出这种函数，说明该系统不支持这种方式～。可以自行下去深入学习一下，加深对IO操作的理解。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">多路复用 select/poll/epoll</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看select函数</span></span><br><span class="line">man select</span><br><span class="line"><span class="meta">#</span><span class="bash">查看poll函数</span></span><br><span class="line">man poll</span><br><span class="line"><span class="meta">#</span><span class="bash">查看epoll</span></span><br><span class="line">man epoll</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">零拷贝相关</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sendfile系统函数</span></span><br><span class="line">man sendfile</span><br><span class="line"><span class="meta">#</span><span class="bash">mmap 系统函数</span></span><br><span class="line">man mmap</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>学习是持之以恒的，也是有方法论的，以下是我个人认为比较好的一些学习方式。</p><ul><li>强势技能的学习<ul><li>现在或者一段时间的未来都会对自己带来很大的帮助</li><li>JDK8、Netty、NodeJs、Kotlin、MongoDB…</li></ul></li><li>重视基础<ul><li>例如Spring的IOC和AOP…</li><li>不管学习什么技能 都一定要学习其原理</li></ul></li><li>节奏感<ul><li>尽可能保存一种稳健的状态去学习、工作、生活、休息</li></ul></li><li>思维方式的改进<ul><li>英文阅读能力</li><li>看不懂没事，尝试去翻译他，尽量记住一些关键的单词，别直接去看博客，可能别人写的博客还是错误的。</li><li>最好最官方的理解一定都是出自于源码和官方文档，自己整理吸收才会成为自己的。</li></ul></li><li>效率工具的使用<ul><li>某基百科，某歌搜索引擎，某overflow，b站，github…都可以给我提供高效的学习途径</li></ul></li><li>主动输出<ul><li>学习的目的是为了解决问题</li><li>解决问题的同时还能跟别人说出来，跟别人讲了别人也能学会</li><li>逼着自己输出</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> BIO </tag>
            
            <tag> NIO </tag>
            
            <tag> AIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty大纲</title>
      <link href="/Netty%E5%A4%A7%E7%BA%B2.html"/>
      <url>/Netty%E5%A4%A7%E7%BA%B2.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Netty是一个提供异步事件驱动的网络应用框架，是一个用以快速开发高性能、可扩展协议的服务器和客户端的工具。换句话说，Netty 是一个 NIO 客户端服务器框架，使用它可以快速简单地开发网络应用程序，比如服务器和客户端的协议。Netty 大大简化了网络编程，比如 TCP 和 UDP 的 socket 服务的开发。</p><a id="more"></a><h2 id="分模块学习"><a href="#分模块学习" class="headerlink" title="分模块学习"></a>分模块学习</h2><p><a href="BIO、NIO、AIO分析.html">Netty基础(AIO、NIO、BIO分析)</a></p><p>Netty模块分析</p><p>Netty Http Tunnel（Http隧道）</p><p>Netty对Socket的实现</p><p>Netty压缩与解压缩</p><p>Netty对RPC的支持</p><p>WebSocket实现与原理</p><p>WebSocket服务端与客户端开发</p><p>RPC框架</p><p>Google Protobuf使用方式分析</p><p>Apache Thrift使用方式与文件编写方式</p><p>Netty大文件传送支持</p><p>可扩展的事件模型</p><p>Netty统一通信API</p><p>零拷贝在Netty中的实现与支持</p><p>TCP粘包与拆包</p><p>NIO模型在Netty 中的实现</p><p>Netty编解码开发技术</p><p>Netty源码分析</p><p>Channel分析</p><p>序列化</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux从认识操作系统开始</title>
      <link href="/linux%E4%BB%8E%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%A7%8B.html"/>
      <url>/linux%E4%BB%8E%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%A7%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-从认识操作系统开始"><a href="#一-从认识操作系统开始" class="headerlink" title="一 从认识操作系统开始"></a><strong>一 从认识操作系统开始</strong></h1><h2 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a><strong>1.1</strong> <strong>操作系统简介</strong></h2><p>我通过以下四点介绍什么是操作系统：</p><ul><li><strong>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</strong></li><li><strong>操作系统本质上是运行在计算机上的软件程序 ；</strong></li><li><strong>为用户提供一个与系统交互的操作界面 ；</strong></li><li><strong>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</strong></li></ul><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181606.png" alt="操作系统分内核与外壳"></p><a id="more"></a><h2 id="1-2-操作系统简单分类"><a href="#1-2-操作系统简单分类" class="headerlink" title="1.2 操作系统简单分类"></a><strong>1.2</strong> <strong>操作系统简单分类</strong></h2><ol><li><strong>Windows:</strong> 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。</li><li><strong>Unix</strong>： 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。 <img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181618.png" alt="Unix"></li><li><strong>Linux:</strong> Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 <strong>Linux内核</strong> 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。</li></ol><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181625.png" alt="Linux"></p><h1 id="二-初探Linux"><a href="#二-初探Linux" class="headerlink" title="二 初探Linux"></a><strong>二 初探Linux</strong></h1><h2 id="2-1-Linux简介"><a href="#2-1-Linux简介" class="headerlink" title="2.1 Linux简介"></a><strong>2.1 Linux简介</strong></h2><p>我们上面已经介绍到了Linux，我们这里只强调三点。</p><ul><li><strong>类Unix系统：</strong> Linux是一种自由、开放源码的类似Unix的操作系统</li><li><strong>Linux内核：</strong> 严格来说，Linux这个词本身只表示Linux内核</li><li><strong>Linux之父：</strong> 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。</li></ul><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181703.png" alt="Linux"></p><h2 id="2-2-Linux诞生简介"><a href="#2-2-Linux诞生简介" class="headerlink" title="2.2 Linux诞生简介"></a><strong>2.2 Linux诞生简介</strong></h2><ul><li>1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中;</li><li>Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</li></ul><h2 id="2-3-Linux的分类"><a href="#2-3-Linux的分类" class="headerlink" title="2.3 Linux的分类"></a><strong>2.3 Linux的分类</strong></h2><p><strong>Linux根据原生程度，分为两种：</strong></p><ol><li><strong>内核版本：</strong> Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等；</li><li><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS），如下图所示： <img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181715.png" alt="Linux发行版本"></li></ol><h1 id="三-虚拟机安装CentOS7"><a href="#三-虚拟机安装CentOS7" class="headerlink" title="三 虚拟机安装CentOS7"></a><strong>三 虚拟机安装CentOS7</strong></h1><h2 id="3-1-VMware安装CentOS7"><a href="#3-1-VMware安装CentOS7" class="headerlink" title="3.1 VMware安装CentOS7"></a><strong>3.1 VMware安装CentOS7</strong></h2><p>参考：<a href="https://blog.csdn.net/guo_ridgepole/article/details/78973763" target="_blank" rel="noopener">https://blog.csdn.net/guo_ridgepole/article/details/78973763</a></p><h2 id="3-2-基本网络配置"><a href="#3-2-基本网络配置" class="headerlink" title="3.2 基本网络配置"></a><strong>3.2 基本网络配置</strong></h2><h3 id="VMware三种网络配置方式"><a href="#VMware三种网络配置方式" class="headerlink" title="VMware三种网络配置方式"></a><strong>VMware三种网络配置方式</strong></h3><h4 id="1-Bridged桥接模式-推荐-："><a href="#1-Bridged桥接模式-推荐-：" class="headerlink" title="1. Bridged桥接模式(推荐)："></a><strong>1. Bridged桥接模式(推荐)：</strong></h4><p>​    VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器，你需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信，虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。</p><h4 id="2-NAT网络地址转换模式："><a href="#2-NAT网络地址转换模式：" class="headerlink" title="2. NAT网络地址转换模式："></a><strong>2. NAT网络地址转换模式：</strong></h4><p>​    虚拟系统借助NAT的功能，通过宿主机所在的网络来访问公网。在这种模式下宿主机成为双网卡主机，同时参与现有的宿主局域网和新建的虚拟局域网，但由于加设了一个虚拟的NAT服务器，使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来看，只能看到宿主机，完全看不到新建的虚拟局域网。</p><h4 id="3-Host-only主机模式："><a href="#3-Host-only主机模式：" class="headerlink" title="3. Host-only主机模式："></a><strong>3. Host-only主机模式：</strong></h4><p>​    新建了一个由所有虚拟机与宿主机所构成的局域网，但该局域网与宿主机本身所处的现有局域网是相互独立的，如果不做额外路由设置，这两个局域网之间不会连通，因此新建的局域网可以认为是一个单独从属于当前宿主机的私有网络，其成员为当前宿主机和相关的所有虚拟机。</p><p><strong>桥接模式网络配置</strong></p><ol><li><strong>配置ip地址等信息</strong><pre><code>在     /etc/sysconfig/network-scripts/ifcfg-eno16777736文件里做如下配置TYPE=Ethernet # 网络类型为以太网BOOTPROTO=static # 手动分配ipDEVICE=eno16777736 # 网卡设备名，设备名一定要跟文件名一致ONBOOT=yes # 该网卡是否随网络服务启动IPADDR=192.168.0.60 # 该网卡ip地址NETMASK=255.255.255.0 # 子网掩码GATEWAY=192.168.0.1 # 网关DNS1=8.8.8.8 # DNS，8.8.8.8为Google提供的免费DNS服务器的IP地址</code></pre></li><li><strong>配置网络工作</strong><pre><code>在/etc/sysconfig/network文件里增加如下配置NETWORKING=yes # 网络是否工作，此处一定不能为no</code></pre></li><li><strong>配置公共DNS服务(可选)</strong><pre><code>在/etc/resolv.conf文件里增加如下配置nameserver 8.8.8.8</code></pre></li><li><strong>关闭防火墙</strong><pre><code>\#systemctl stop firewalld # 临时关闭防火墙\#systemctl disable firewalld # 禁止开机启动</code></pre></li><li><strong>重启网络服务</strong><pre><code>\#service network restart</code></pre></li></ol><h1 id="四-Linux文件系统概览"><a href="#四-Linux文件系统概览" class="headerlink" title="四 Linux文件系统概览"></a><strong>四 Linux文件系统概览</strong></h1><h2 id="4-1-Linux文件系统简介"><a href="#4-1-Linux文件系统简介" class="headerlink" title="4.1 Linux文件系统简介"></a><strong>4.1 Linux文件系统简介</strong></h2><p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><p>也就是说在LINUX系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><h2 id="4-2-文件目录结构"><a href="#4-2-文件目录结构" class="headerlink" title="4.2 文件目录结构"></a><strong>4.2 文件目录结构</strong></h2><p><strong>Linux的目录结构如下：</strong></p><p>Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录： <img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181756.png" alt="Linux的目录结构"></p><p><strong>常见目录说明：</strong></p><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</li><li><strong>/etc：</strong> 存放系统管理和配置文件；</li><li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr</strong> <strong>：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级o）；</li><li><strong>/sbin:</strong> 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>/lib</strong> <strong>：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h1 id="五-Linux基本命令"><a href="#五-Linux基本命令" class="headerlink" title="五 Linux基本命令"></a><strong>五 Linux基本命令</strong></h1><p>Linux命令用法一般用man命令可以查看其帮助信息</p><p>下面给出了一些比较常用的命令。推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p><p>中文Linux命令帮助大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><h2 id="5-1-目录切换命令"><a href="#5-1-目录切换命令" class="headerlink" title="5.1 目录切换命令"></a><strong>5.1</strong> <strong>目录切换命令</strong></h2><ul><li><strong>cd usr：</strong> 切换到该目录下usr目录</li><li><strong>cd ..（或cd../）：</strong> 切换到上一层目录</li><li><strong>cd /：</strong> 切换到系统根目录</li><li><strong>cd ~：</strong> 切换到用户主目录</li><li><strong>cd -：</strong> 切换到上一个所在目录</li></ul><h2 id="5-2-目录的操作命令（增删改查）"><a href="#5-2-目录的操作命令（增删改查）" class="headerlink" title="5.2 目录的操作命令（增删改查）"></a><strong>5.2</strong> <strong>目录的操作命令（增删改查）</strong></h2><ol><li><strong>mkdir</strong> <strong>目录名称：</strong> 增加目录</li><li><strong>ls或者ll</strong>（ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息</li><li><strong>find</strong> <strong>目录</strong> <strong>参数：</strong> 寻找目录（查）</li></ol><p>示例：</p><ol><li><ul><li>列出当前目录及子目录下所有文件和文件夹: find .<ul><li>在/home目录下查找以.txt结尾的文件名:find /home -name “*.txt”</li><li>同上，但忽略大小写: find /home -iname “*.txt”</li><li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:find . ( -name      “<em>.txt” -o -name “</em>.pdf” )或find . -name      “<em>.txt” -o -name “</em>.pdf”</li></ul></li></ul></li><li><p><strong>mv</strong> <strong>目录名称</strong> <strong>新目录名称：</strong> 修改目录的名称（改）</p></li></ol><p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p><ol><li><strong>mv</strong> <strong>目录名称</strong> <strong>目录的新位置：</strong> 移动目录的位置—剪切（改）</li></ol><p>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p><ol><li><strong>cp -r</strong> <strong>目录名称</strong> <strong>目录拷贝的目标位置：</strong> 拷贝目录（改），-r代表递归拷贝</li></ol><p>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归</p><ol><li><strong>rm [-rf]</strong> <strong>目录:</strong> 删除目录（删）</li></ol><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包</p><h2 id="5-3-文件的操作命令（增删改查）"><a href="#5-3-文件的操作命令（增删改查）" class="headerlink" title="5.3 文件的操作命令（增删改查）"></a><strong>5.3</strong> <strong>文件的操作命令（增删改查）</strong></h2><ol><li><p><strong>touch</strong> <strong>文件名称:</strong> 文件的创建（增）</p></li><li><p><strong>cat /more/less/tail</strong> <strong>文件名称</strong> 文件的查看（查）</p></li><li><ul><li><strong>cat：</strong> 只能显示最后一屏内容<ul><li><strong>more：</strong> 可以显示百分比，回车可以向下一行，      空格可以向下一页，q可以退出查看</li><li><strong>less：</strong> 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li><li><strong>head -10</strong> <strong>：</strong> 查看文件的前10行，Ctrl+C结束</li><li><strong>tail -10</strong> <strong>：</strong> 查看文件的后10行，Ctrl+C结束</li></ul></li></ul></li></ol><p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化</p><h3 id="5-3-1-vim-文件"><a href="#5-3-1-vim-文件" class="headerlink" title="5.3.1 vim 文件"></a><strong>5.3.1 vim</strong> <strong>文件</strong></h3><p>修改文件的内容（改）</p><p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，这里列出一些常用命令。</p><p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件和编写shell脚本，下面是一般步骤：</strong></p><p>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a><strong>命令模式</strong></h4><p>用vim 打开一个文件刚开始进入的就是命令模式，在这个模式下我们可以控制光标的移动，字符，字或者行的删除，移动复制某段区域，在该模式下可以进入插入模式也可以进入底行模式。</p><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a><strong>编辑模式</strong></h4><p>在编辑模式下才可以插入文字，按Esc进入底行模式.</p><h4 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a><strong>底行模式</strong></h4><p>在底行模式下保存文件或者退出vim</p><h3 id="5-3-2-vim常用命令："><a href="#5-3-2-vim常用命令：" class="headerlink" title="5.3.2 vim常用命令："></a><strong>5.3.2 vim常用命令：</strong></h3><h4 id="1-移动光标"><a href="#1-移动光标" class="headerlink" title="1).移动光标"></a><strong>1).移动光标</strong></h4><p>1.vim 可以使用小写英文字母 h j k l 分别控制光标左 下 上 右移动，也可以使用箭头</p><p> 2.Ctrl+<strong>b</strong> 屏幕往后移动一页</p><p> 3.Ctrl+f 屏幕往前移动一页</p><p> 4.Ctrl+u 屏幕往后移动半页</p><p> 5.Ctrl+d 屏幕往前移动半页</p><p> 6.Shift+g == G 移动到文章的最后</p><p> 7.Shift+4 == $ 移动到光标所在行的行尾</p><p> 8.Shift+6 == ^ 移动到光标所在行的行首</p><p> 9.w 光标跳到下个字的开头</p><p>10.e 光标跳到下个字的字尾</p><p>11.b 光标回到上个字的开头</p><p>12.<strong>#l</strong> 例如:5l ，56l 光标移动到该行的第’#’个位置</p><p>13.gg 进入到文本的开始</p><h4 id="2-删除文字"><a href="#2-删除文字" class="headerlink" title="2).删除文字"></a><strong>2).删除文字</strong></h4><p>1.x 每按一次删除光标所在位置的一个字符</p><p>  2.#x 栗子：6x 删除光标所在位置的”后面”(包含自己在内)6个字符</p><p>  3.Shift+x == X 每按一次，删除光标所在位置的前一个字符</p><p>  4.Shift+#x == #X 栗子 20X 删除光标所在位置的前面20个字符</p><p>  5.dd 删除光标所在行</p><p>  6.#dd 栗子 6dd 从光标所在行开始删除6行</p><h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3).复制"></a><strong>3).复制</strong></h4><p>1.yw 将光标所在之处到字尾的字符复制到缓冲区中</p><p>  2.<strong>#yw</strong> 栗子 6yw 复制6个字符到缓冲区</p><p>  3.yy 复制光标所在行到缓冲区</p><p>  4.<strong>#yy</strong> 栗子 6yy 拷贝从光标所在的该行”往下数”6行文字</p><p>  5.p 将缓冲区内的字符贴到光标所在位置</p><p> 注意：所有与y有关的复制命令都必须与p配合才能完成复制粘贴功能</p><h4 id="4-替换"><a href="#4-替换" class="headerlink" title="4).替换"></a><strong>4).替换</strong></h4><p>1.r 替换光标所在处的字符</p><p>  2.R 替换光标所到之处的字符，知道按下Esc键为止.</p><h4 id="5-撤销上一次的操作"><a href="#5-撤销上一次的操作" class="headerlink" title="5).撤销上一次的操作"></a><strong>5).撤销上一次的操作</strong></h4><p>u 回到上一个操作，按动多次’u’可以执行多次回复</p><h4 id="6-更改"><a href="#6-更改" class="headerlink" title="6).更改"></a><strong>6).更改</strong></h4><p>1.cw 更改光标所在处的字到字尾处</p><p>  2.c<strong>#w</strong> 栗子 c3w 表示更改三个字</p><h4 id="7-跳至指定行"><a href="#7-跳至指定行" class="headerlink" title="7).跳至指定行"></a><strong>7).跳至指定行</strong></h4><p>1.Ctrl+g 列出光标所在行的行号</p><p> 2.#G 栗子 15G 表示移动光标到文章的第15行行首</p><ol><li><strong>rm -rf</strong> <strong>文件：</strong> 删除文件（删）</li></ol><p>同目录删除：熟记 rm -rf 文件 即可</p><h2 id="5-4-压缩文件的操作命令"><a href="#5-4-压缩文件的操作命令" class="headerlink" title="5.4 压缩文件的操作命令"></a><strong>5.4</strong> <strong>压缩文件的操作命令</strong></h2><h3 id="1）打包并压缩文件："><a href="#1）打包并压缩文件：" class="headerlink" title="1）打包并压缩文件："></a><strong>1）打包并压缩文件：</strong></h3><p>Linux中的打包文件一般是以.tar结尾的，压缩的文件一般是以.gz结尾的。</p><p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<strong>tar -zcvf</strong> <strong>打包压缩后的文件名</strong> <strong>要打包压缩的文件</strong> 其中：</p><p>z：调用gzip压缩命令进行压缩</p><p>c：打包文件</p><p>v：显示运行过程</p><p>f：指定文件名</p><p>比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</strong> <strong>或：</strong> <strong>tar -zcvf test.tar.gz /test/</strong></p><h3 id="2-）解压压缩包："><a href="#2-）解压压缩包：" class="headerlink" title="2 ）解压压缩包："></a><strong>2</strong> <strong>）解压压缩包：</strong></h3><p>命令：tar [-xvf] 压缩文件</p><p>其中：x：代表解压</p><p>示例：</p><p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong>tar -xvf test.tar.gz</strong></p><p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong>tar -xvf xxx.tar.gz -C /usr</strong>（- C代表指定解压的位置）</p><h2 id="5-5-Linux的权限命令"><a href="#5-5-Linux的权限命令" class="headerlink" title="5.5 Linux的权限命令"></a><strong>5.5 Linux的权限命令</strong></h2><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong>ls -l</strong> 命令我们可以 查看某个目录下的文件或目录的权限</p><p>示例：在随意某个目录下ls -l</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181816.png" alt="权限标识"></p><p>第一列的内容的信息解释如下：</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181828.png" alt="权限详解"></p><p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p><h3 id="文件的类型："><a href="#文件的类型：" class="headerlink" title="文件的类型："></a><strong>文件的类型：</strong></h3><ul><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表链接（可以认为是window中的快捷方式）</li></ul><h3 id="Linux-中权限分为以下几种："><a href="#Linux-中权限分为以下几种：" class="headerlink" title="Linux 中权限分为以下几种："></a><strong>Linux</strong> <strong>中权限分为以下几种：</strong></h3><ul><li>r：代表权限是可读，r也可以用数字4表示</li><li>w：代表权限是可写，w也可以用数字2表示</li><li>x：代表权限是可执行，x也可以用数字1表示</li></ul><h3 id="文件和目录权限的区别："><a href="#文件和目录权限的区别：" class="headerlink" title="文件和目录权限的区别："></a><strong>文件和目录权限的区别：</strong></h3><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th><strong>权限名称</strong></th><th><strong>可执行操作</strong></th></tr></thead><tbody><tr><td>r</td><td>可以使用cat查看文件的内容</td></tr><tr><td>w</td><td>可以修改文件的内容</td></tr><tr><td>x</td><td>可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th><strong>权限名称</strong></th><th><strong>可执行操作</strong></th></tr></thead><tbody><tr><td>r</td><td>可以查看目录下列表</td></tr><tr><td>w</td><td>可以创建和删除目录下文件</td></tr><tr><td>x</td><td>可以使用cd进入目录</td></tr></tbody></table><p><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><strong>所有者</strong></li></ul><p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐l命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。</p><ul><li><strong>文件所在组</strong></li></ul><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐l命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。</p><ul><li><strong>其它组</strong></li></ul><p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p><p>我们再来看看如何修改文件/目录的权限。</p><p><strong>修改文件/目录的权限的命令：</strong> <strong>chmod</strong></p><p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限</p><p><strong>chmod u=rwx,g=rw,o=r aaa.txt</strong></p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201108181836.png" alt="修改权限"></p><p>上述示例还可以使用数字表示：</p><p>chmod 764 aaa.txt</p><h3 id="补充一个比较常用的东西"><a href="#补充一个比较常用的东西" class="headerlink" title="补充一个比较常用的东西:"></a><strong>补充一个比较常用的东西:</strong></h3><p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p><ol><li>新建一个脚本zookeeper</li><li>为新建的脚本zookeeper添加可执行权限，命令是:chmod +x zookeeper</li><li>把zookeeper这个脚本添加到开机启动项里面，命令是：chkconfig –add zookeeper</li><li>如果想看看是否添加成功，命令是：chkconfig –list</li></ol><h2 id="5-6-Linux用户管理"><a href="#5-6-Linux用户管理" class="headerlink" title="5.6 Linux用户管理"></a><strong>5.6 Linux用户管理</strong></h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><h3 id="Linux-用户管理相关命令"><a href="#Linux-用户管理相关命令" class="headerlink" title="Linux 用户管理相关命令:"></a><strong>Linux</strong> <strong>用户管理相关命令:</strong></h3><ul><li>useradd 选项 用户名:添加用户账号</li><li>userdel 选项 用户名:删除用户帐号</li><li>usermod 选项 用户名:修改帐号</li><li>passwd 用户名:更改或创建用户的密码</li><li>passwd -S 用户名 :显示用户账号密码信息</li><li>passwd -d 用户名: 清除用户密码</li><li>su - 用户名：切换登录用户</li></ul><p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。该文件内容的解释：用户名:密码:用户id:组id:用户说明:用户的主目录:用户使用的shell环境(默认为bash)</p><p>passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h2 id="5-7-Linux系统用户组的管理"><a href="#5-7-Linux系统用户组的管理" class="headerlink" title="5.7 Linux系统用户组的管理"></a><strong>5.7 Linux系统用户组的管理</strong></h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><h3 id="Linux-系统用户组的管理相关命令"><a href="#Linux-系统用户组的管理相关命令" class="headerlink" title="Linux 系统用户组的管理相关命令:"></a><strong>Linux</strong> <strong>系统用户组的管理相关命令:</strong></h3><ul><li>groupadd 选项 用户组 :增加一个新的用户组</li><li>groupdel 用户组:要删除一个已有的用户组</li><li>groupmod 选项 用户组 : 修改用户组的属性</li></ul><h2 id="5-8-其他常用命令"><a href="#5-8-其他常用命令" class="headerlink" title="5.8 其他常用命令"></a><strong>5.8</strong> <strong>其他常用命令</strong></h2><ul><li><strong>pwd：</strong> 显示当前所在位置</li><li><strong>grep</strong> <strong>要搜索的字符串</strong> <strong>要搜索的文件</strong> <strong>–color</strong> <strong>：</strong> 搜索命令，–color代表高亮显示</li><li><strong>ps -ef</strong> <strong>/</strong> <strong>ps aux</strong> <strong>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong>ps aux|grep redis</strong> （查看包括redis字符串的进程）</li></ul><p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p><ul><li><strong>kill -9</strong> <strong>进程的</strong> <strong>pid：</strong> 杀死进程（-9 表示强制终止。）</li></ul><p>先用ps查找进程，然后用kill杀掉</p><ul><li><p><strong>网络通信命令：</strong></p></li><li><ul><li><p>查看当前系统的网卡信息：ifconfig</p><ul><li><p>查看与某台机器的连接情况：ping</p></li><li><p>查看当前系统的端口：netstat</p></li><li><ul><li>an 所有的连接和端口<ul><li>tuln 查看正在监听TCP（t）和UDP（u）的端口 ，例如：netstat -tuln | grep LISTEN</li><li>rn 查看网关       route -n</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>ln：</strong> 创建链接文件</p></li><li><ul><li><p>创建软链接文件：ln -s [源文件] [目标文件] (硬链接不需-s选项)</p><ul><li><ul><li>软链接特点：权限是所有人都可以访问，并且软连接文件指向源文件。<ul><li>软链接就像windows系统中的快捷方式一样，特点也都类似。</li><li>硬链接：类似copy，硬链接大小和源文件一样，并且是同步更新的。</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>shutdown：</strong> shutdown -h now： 指定现在立即关机；shutdown +5 “System will shutdown after 5 minutes”:指定5分钟后关机，同时送出警告信息给登入用户。</p></li><li><p><strong>reboot：</strong> <strong>reboot</strong> <strong>：</strong> 重开机。<strong>reboot -w</strong> <strong>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p></li></ul><h1 id="六-安装JDK"><a href="#六-安装JDK" class="headerlink" title="六 安装JDK"></a><strong>六 安装JDK</strong></h1><h2 id="6-1-用JDK安装包安装"><a href="#6-1-用JDK安装包安装" class="headerlink" title="6.1 用JDK安装包安装"></a><strong>6.1</strong> <strong>用JDK安装包安装</strong></h2><ol><li>查看是否已经安装JDK：rpm -qa | grep -i java</li><li>若有则删除：rpm -e –nodeps java-xxx，删除所有相关的java</li><li>下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk8</a>安装包，将gz压缩文件放到指定目录如/usr/local，解压：tar -zxvf     jdk-8u181-linux-x64.tar.gz</li><li>设置全局变量：vim /etc/profile，追加<pre><code>JAVA_HOME=/usr/local/jdk1.8.0_181CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH</code></pre></li><li>source /etc/profile</li><li>java -version</li></ol><h2 id="6-2-用yum方式安装-无需配置环境变量"><a href="#6-2-用yum方式安装-无需配置环境变量" class="headerlink" title="6.2 用yum方式安装(无需配置环境变量)"></a><strong>6.2</strong> <strong>用yum方式安装(无需配置环境变量)</strong></h2><ol><li>检索yum中有没有java1.8的包：yum list java-1.8*</li><li>yum install java-1.8.0-openjdk* -y</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作命令 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql共享锁、排他锁</title>
      <link href="/Mysql%E5%85%B1%E4%BA%AB%E9%94%81%E3%80%81%E6%8E%92%E4%BB%96%E9%94%81.html"/>
      <url>/Mysql%E5%85%B1%E4%BA%AB%E9%94%81%E3%80%81%E6%8E%92%E4%BB%96%E9%94%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql共享锁、排他锁"><a href="#Mysql共享锁、排他锁" class="headerlink" title="Mysql共享锁、排他锁"></a>Mysql共享锁、排他锁</h1><h2 id="名词及含义"><a href="#名词及含义" class="headerlink" title="名词及含义"></a><strong>名词及含义</strong></h2><ul><li>表级锁（锁定整个表）</li><li>页级锁（锁定一页）</li><li>行级锁（锁定一行）</li><li>共享锁（S锁，MyISAM 叫做读锁）</li><li>排他锁（X锁，MyISAM 叫做写锁）</li><li>间隙锁（NEXT-KEY锁）</li><li>悲观锁（抽象性，不真实存在这个锁）</li><li>乐观锁（抽象性，不真实存在这个锁）</li></ul><a id="more"></a><h2 id="InnoDB与MyISAM"><a href="#InnoDB与MyISAM" class="headerlink" title="InnoDB与MyISAM"></a><strong>InnoDB与MyISAM</strong></h2><p>我之前专程写了<a href="https://www.wukong918.cn/Mysql%E4%B8%ADMyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB.html"><font color="0099ff">Mysql中MyISAM和InnoDB区别</font></a>和<a href="https://www.wukong918.cn/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"><font color="0099ff">Mysql存储引擎</font></a></p><p>这里主要写一些影响锁相关的内容</p><p>Mysql 在5.5之前默认使用 MyISAM 存储引擎，之后使用 InnoDB 。查看当前存储引擎：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%storage_engine%&#39;;</span><br></pre></td></tr></table></figure><p>MyISAM 操作数据都是使用的表锁，你更新一条记录就要锁整个表，导致性能较低，并发不高。当然同时它也不会存在死锁问题。</p><p>而 InnoDB 与 MyISAM 的最大不同有两点：<font color="red"><strong>一是 InnoDB 支持事务；二是 InnoDB 采用了行级锁</strong></font>。也就是你需要修改哪行，就可以只锁定哪行。</p><p>在 Mysql 中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql 语句操作了主键索引，Mysql 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。</p><p>InnoDB 行锁是通过给索引项加锁实现的，如果没有索引，InnoDB 会通过隐藏的聚簇索引来对记录加锁。也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。因为没有了索引，找到某一条记录就得扫描全表，要扫描全表，就得锁定表。</p><h2 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a><strong>共享锁与排他锁</strong></h2><p><font color = "red">数据库的<strong>增删改</strong>操作默认都会加<strong>排他锁</strong></font>，而查询不会加任何锁。</p><p>mysql InnoDB引擎默认的修改数据语句，<strong>update</strong>,<strong>delete</strong>,<strong>insert</strong>都会自动给涉及到的数据加上<strong>排他锁</strong>，<strong>select</strong>语句默认不会加任何锁类型，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</p><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a><strong>共享锁</strong></h3><p>对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后。语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table lock in share mode</span><br></pre></td></tr></table></figure><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a><strong>排他锁</strong></h3><p>对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table for update</span><br></pre></td></tr></table></figure><p><font color="red">排他锁和共享锁 只会对加锁的sql语句进行阻塞</font></p><p>例如A事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start TRANSACTION;</span><br><span class="line">select * from table_name where id &#x3D; 1 for UPDATE;</span><br></pre></td></tr></table></figure><p>B事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 不会阻塞 直接查出答案</span><br><span class="line">select * from table_name where id &#x3D; 1</span><br></pre></td></tr></table></figure><p>C事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 阻塞 等待事务A提交</span><br><span class="line">select * from table_name where id &#x3D; 1 for UPDATE;</span><br></pre></td></tr></table></figure><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a><strong>间隙锁</strong></h2><h3 id="什么叫间隙锁"><a href="#什么叫间隙锁" class="headerlink" title="什么叫间隙锁"></a>什么叫间隙锁</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(NEXT-KEY)锁。</p><h3 id="间隙锁的产生"><a href="#间隙锁的产生" class="headerlink" title="间隙锁的产生"></a>间隙锁的产生</h3><p>上面的文字很抽象，现在举个栗子，介绍间隙锁是怎么产生的：</p><p>假设有以下表t_student：    </p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>0</td><td>cq</td></tr><tr><td>3</td><td>b</td><td>1</td><td>cq</td></tr><tr><td>4</td><td>c</td><td>0</td><td>cq</td></tr><tr><td>5</td><td>d</td><td>1</td><td>cq</td></tr><tr><td>6</td><td>e</td><td>0</td><td>cq</td></tr></tbody></table><p>这个时候我们发出一条这样的加锁sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start TRANSACTION;</span><br><span class="line">select id,name from t_student where id &gt; 0 and id &lt; 5 for update;</span><br></pre></td></tr></table></figure><p>这时候，我们命中的数据为以下加粗部分：</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>address</th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>a</strong></td><td><strong>0</strong></td><td><strong>cq</strong></td></tr><tr><td><strong>3</strong></td><td><strong>b</strong></td><td><strong>1</strong></td><td><strong>cq</strong></td></tr><tr><td><strong>4</strong></td><td><strong>c</strong></td><td><strong>0</strong></td><td><strong>cq</strong></td></tr><tr><td>5</td><td>d</td><td>1</td><td>cq</td></tr><tr><td>6</td><td>e</td><td>0</td><td>cq</td></tr></tbody></table><p>细心的朋友可能就会发现，这里缺少了条id为2的记录，我们的重点就在这里。</p><p><code>select ... for update</code>这条语句，是会对数据记录加锁的，这里因为命中了索引，加的是行锁。从数据记录来看，这里排它锁锁住数据是id为1、3和4的这3条数据。</p><p>但是，看看前面我们的介绍——对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁。</p><p>好了，我们这里，键值在条件范围但是不存在的记录，就是id为2的记录，这里会对id为2数据加上间隙锁。假设这时候如果有id=2的记录insert进来了，是要等到这个事务结束以后才会执行的</p><h3 id="间隙锁的作用"><a href="#间隙锁的作用" class="headerlink" title="间隙锁的作用"></a>间隙锁的作用</h3><p>总的来说，有2个作用：防止幻读和防止数据误删/改</p><p>因为加锁了，所以其他（删/改/增）都会被阻塞</p><h3 id="使用间隙锁的隐患"><a href="#使用间隙锁的隐患" class="headerlink" title="使用间隙锁的隐患"></a>使用间隙锁的隐患</h3><p>最大的隐患就是性能问题</p><p>如果间隙锁出现死锁的情况下，会更隐晦，更难定位</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 共享锁 </tag>
            
            <tag> 排他锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transactional事务隔离级别和传播性</title>
      <link href="/@Transactional%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E6%80%A7.html"/>
      <url>/@Transactional%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E6%80%A7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h1><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>定义一个事务受其他并发事务影响程度。事务并发引发的问题。</p><ul><li>脏读：一个事务读取到另一个事务修改但还未提交的数据</li><li>不可重复读：一个事务读取数据之后，该数据被其他事务修改，此时第一个事务读取到的事务就是错误的（强调修改）</li><li>幻读：一个事务读取了某些数据，没提交再读取时数据多了或者少了，类似幻觉（强调增删）</li><li>丢失修改：两个事务都读取了数据，其中一个事务修改之后，另一个事务也做了修改，前者的修改丢失。<a id="more"></a>我们这里先看看@Transaction注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以放在 类上 或者 方法上。 </span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区别于 transactionManager属性</span></span><br><span class="line"><span class="comment"> * 查看 transactionManager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"transactionManager"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选定特定的 事务管理器 SpringBoot中默认不用配置 可以是beanName或者特定的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置传播级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置事务隔离级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务只读 默认是可以修改的 如果设置为true只能执行查询相关</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定错误回滚 当未抛出该类型的错误或者其子类的错误时 不会回滚 默认是任何错误（异常）都会回滚</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 略 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果配置这个 如果抛出此异常将不会回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 略 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这上面我们主要关注 <code>isolation</code>（事务隔离级别）和<code>propagation</code>(事务传播级别)</p><h3 id="五种隔离级别（RU、RC、RR、Serializable）"><a href="#五种隔离级别（RU、RC、RR、Serializable）" class="headerlink" title="五种隔离级别（RU、RC、RR、Serializable）"></a>五种隔离级别（RU、RC、RR、Serializable）</h3><p>这里的隔离级别也映射了Mysql或Oracle的隔离级别。  </p><p>我们先查看一下<code>Isolation</code>枚举类的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Isolation &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认的隔离级别</span></span><br><span class="line"><span class="comment"> * 所有其他级别对应于JDBC隔离级别</span></span><br><span class="line"><span class="comment"> * 具体隔离级别 查看 java.sql.Connection</span></span><br><span class="line"><span class="comment"> * Mysql 默认 RR(REPEATABLE_READ)</span></span><br><span class="line"><span class="comment"> * Oracle 默认 RC(READ_COMMITTED)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未提交读 什么问题都不解决</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_UNCOMMITTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交读 解决脏读</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_COMMITTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重复读 解决脏读和不可重复读 不解决幻读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 串行读 解决所有的事务隔离问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ_UNCOMMITTED</td><td><font color="red"><strong>×</strong></font></td><td><font color="red"><strong>×</strong></font></td><td><font color="red"><strong>×</strong></font></td></tr><tr><td>READ_COMMITTED</td><td><font color='green'><strong>√</strong></font></td><td><font color="red"><strong>×</strong></font></td><td><font color="red"><strong>×</strong></font></td></tr><tr><td>REPEATABLE_READ</td><td><font color='green'><strong>√</strong></font></td><td><font color='green'><strong>√</strong></font></td><td><font color="red"><strong>×</strong></font></td></tr><tr><td>SERIALIZABLE</td><td><font color='green'><strong>√</strong></font></td><td><font color='green'><strong>√</strong></font></td><td><font color='green'><strong>√</strong></font></td></tr></tbody></table><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>用来描述 <strong>一个被事务传播行为修饰的方法</strong> 被 <strong>嵌套进另一个方法</strong> 时，事务如何传播。</p><p>在Spring的@Transaction中，有个重要的属性：Propagation，指的是事务方法之间发生嵌套调用时，事务的传播行为（当前调用的这个方法的事务，和当前的其他事务之间的关系）。</p><p>我们查看一下<code>Propagation</code>枚举类的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Propagation &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, create a new one if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the default setting of a transaction annotation.</span></span><br><span class="line"><span class="comment"> * 外围有事务则加入形成同一个事务，外围无事务则新开启，内部事务之间相互独立</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, execute non-transactionally if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span></span><br><span class="line"><span class="comment"> * as it defines a transaction scope that synchronization will apply for.</span></span><br><span class="line"><span class="comment"> * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span></span><br><span class="line"><span class="comment"> * will be shared for the entire specified scope. Note that this depends on</span></span><br><span class="line"><span class="comment"> * the actual synchronization configuration of the transaction manager.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span></span><br><span class="line"><span class="comment"> * 若外围没有事务则非事务执行，有事务则同 REQUIRED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support a current transaction, throw an exception if none exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * 使用外围事务，若外围无事务则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new transaction, and suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment"> * Analogous to the EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment"> * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment"> * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment"> * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment"> * 外围有无事务都开启新事务，相互独立，且与外围事务相互独立开 如果当前有事务，就把当前的事务挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute non-transactionally, suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment"> * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment"> * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment"> * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment"> * 非事务执行，若外围存在事务则挂起该事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute non-transactionally, throw an exception if a transaction exists.</span></span><br><span class="line"><span class="comment"> * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment"> * 非事务执行，当外围有事务则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute within a nested transaction if a current transaction exists,</span></span><br><span class="line"><span class="comment"> * behave like &#123;<span class="doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span></span><br><span class="line"><span class="comment"> * transaction managers. Out of the box, this only applies to the JDBC</span></span><br><span class="line"><span class="comment"> * DataSourceTransactionManager. Some JTA providers might support nested</span></span><br><span class="line"><span class="comment"> * transactions as well.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br><span class="line"><span class="comment"> * 外围无事务，则同 REQUIRED 内部开启新事务相互独立。外围有事务，则内部事务是其子事务，主事务回滚则子事务全部回滚，子事务回滚不影响其他子事务和主事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我们的日常开发过程中，设计到数据安全相关的问题的时候切记要选择正确的事务隔离和事务传播，多测试，以免造成没必要的经济损失。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 事务隔离级别 </tag>
            
            <tag> 事务传播性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中MVCC原理</title>
      <link href="/Mysql%E4%B8%ADMVCC%E5%8E%9F%E7%90%86.html"/>
      <url>/Mysql%E4%B8%ADMVCC%E5%8E%9F%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql中MVCC原理"><a href="#Mysql中MVCC原理" class="headerlink" title="Mysql中MVCC原理"></a>Mysql中MVCC原理</h1><h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC?"></a>什么是MVCC?</h2><p>英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制。他无非就是乐观锁的一种实现方式。在Java编程中，如果把乐观锁看成一个接口，MVCC便是这个接口的一个实现类而已。</p><a id="more"></a><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1.MVCC其实广泛应用于数据库技术，像Oracle,PostgreSQL等也引入了该技术，即适用范围广</p><p>2.MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</p><h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本。</li><li>修改时Copy出当前版本随意修改，各个事务之间无干扰。</li><li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li></ul><h1 id="InnoDB存储引擎MVCC的实现策略"><a href="#InnoDB存储引擎MVCC的实现策略" class="headerlink" title="InnoDB存储引擎MVCC的实现策略"></a>InnoDB存储引擎MVCC的实现策略</h1><p>在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。</p><p>每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说你不想只搬砖？——Mysql中查询缓存优化</title>
      <link href="/%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B8%8D%E6%83%B3%E5%8F%AA%E6%90%AC%E7%A0%96%EF%BC%9F%E2%80%94%E2%80%94Mysql%E4%B8%AD%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96.html"/>
      <url>/%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B8%8D%E6%83%B3%E5%8F%AA%E6%90%AC%E7%A0%96%EF%BC%9F%E2%80%94%E2%80%94Mysql%E4%B8%AD%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql中查询缓存优化"><a href="#Mysql中查询缓存优化" class="headerlink" title="Mysql中查询缓存优化"></a>Mysql中查询缓存优化</h1><p>在实际的业务环境中，我们可能会存在重复查询相同sql的数据，其实这样每次都用Mysql走文件或索引查询数据的效率是非常的慢的，所以我们需要引入Mysql中的查询缓存。当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。</p><p>当然使用 mysql 缓存也不是没有坏处，mysql 多了个管理缓存的任务，需要写入缓存，然后如果判断里面的缓存已经过期，又要从里面删除缓存。</p><p><font color='red'>博主在学习的时候发现Mysql8已经废弃了这个功能，大家学习的时候可以当作了解。</font>因为现在的缓存工具很多，比如redis、memcache这些内存型缓存。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'have_query_cache';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| have_query_cache | NO    |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200616211623.jpg" alt="Mysql查询sql流程"></p><a id="more"></a><ol><li>客户端发送一条查询给服务器</li><li>服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段。</li><li>服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划。</li><li>Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询</li><li>将结果返回客户端</li></ol><h2 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h2><ol><li><p>查看当前的MySQL数据库是否支持查询缓存</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'have_query_cache';</span><br></pre></td></tr></table></figure></li><li><p>查询当前MySQL是否开启了查询缓存</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'query_cache_type';</span><br></pre></td></tr></table></figure></li><li><p>查询缓存占用大小 查询出来的单位为byte</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'query_cache_size';</span><br></pre></td></tr></table></figure></li><li><p>查询缓存的状态变量</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'Qcache%';</span><br></pre></td></tr></table></figure><p> 各个缓存状态含义如下:</p><ul><li>Qcache_free_blocks 查询缓存中的可用内存块数</li><li>Qcache_free_memory 查询缓存的可用内存量</li><li>Qcache_hits 查询缓存命中数</li><li>Qcache_inserts 添加到查询缓存的查询数</li><li>Qcache_lowmen_prunes 由于内存不足而从查询缓存中删除的查询数</li><li>Qcache_not_cached 非缓存查询的数量（由于query_cache_type设置而无法缓存或未缓存）</li><li>Qcache_queries_in_cache 查询缓存中注册的查询数</li><li>Qcache_total_blocks 查询缓存中的块总数</li></ul></li><li><p>开启查询缓存</p><p> Mysql的查询缓存默认是关闭的，需要手动配置参数<code>query_cache_type</code>来开启查询缓存。query_cache_type该参数可取值有三个</p><ul><li><p>OFF或0  查询缓存功能关闭</p></li><li><p>ON或1  查询缓存功能打开，SELECT结果复合缓存条件就会缓存，否则不缓存，显式指定SQL_NO_CACHE，不缓存</p></li><li><p>DEMAND或2  查询缓存功能按需进行，显示指定SQL_CACHE的SELECT语句才会缓存；其他都不会缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mysql配置文件 开启查询缓存</span></span><br><span class="line">query_cache_type = 1</span><br><span class="line"><span class="comment"># 开启后需要重启Mysql</span></span><br></pre></td></tr></table></figure><p>然后就可以在命令行执行SQL语句进行验证，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面执行效率。</p><p>最后对比<code>show status like &#39;Qcache%&#39;;</code>查询出来的状态变量，对比缓存命中数等等。</p></li></ul></li><li><p>查询缓存SELECT选项</p><p> 可以在SELECT语句中指定两个与查询缓存相关的选项：</p><p> SQL_CACHE：如果查询结果是可缓存的，并且query_cache_type系统变量的值为ON或DEMAND，则缓存查询结果</p><p> SQL_NO_CACHE：服务器不使用查询缓存。它不检查查询缓存是否开启，也不检查结果是否已缓存，也不缓存查询结果。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> table_name;</span><br><span class="line"><span class="keyword">select</span> SQL_NO_CACHE <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>查询缓存失效的情况</p><ul><li>SQL语句不一致的情况，想要命中查询缓存，查询的SQL语句必须一致</li><li>当查询语句中有一些不确定的时，则不会缓存。如now()、current_date()、curdate()、rand()、uuid()等等</li><li>不使用任何表查询语句</li><li>查询mysql，information_schema或performance_sachema数据库中表时，不会走查询缓存</li><li>在存储的函数，触发器或事件的主体内执行的查询</li><li>如果表更改，则使用该表的所有高速缓存查询都将变为无效并且从高速缓存中删除。这包括使用MERGE映射到已更改的表查询。一个表可以被许多类型的语句改变，如被改变INSERT，UPDATE，DELETE，TRUNCATE TABLE，ALTER TABLE，DROP TABLE或DROP DATABASE</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> sql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说你不想只搬砖？——Mysql中索引相关和SQL优化</title>
      <link href="/%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B8%8D%E6%83%B3%E5%8F%AA%E6%90%AC%E7%A0%96%EF%BC%9F%E2%80%94%E2%80%94Mysql%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E5%92%8CSQL%E4%BC%98%E5%8C%96.html"/>
      <url>/%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B8%8D%E6%83%B3%E5%8F%AA%E6%90%AC%E7%A0%96%EF%BC%9F%E2%80%94%E2%80%94Mysql%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E5%92%8CSQL%E4%BC%98%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h1><p>索引是数据库优化最常用的手段之一，通过索引通常可以帮助用户解决大多数的MySQL性能优化问题。</p><p>以下的所有操作都只是抛砖引玉的作用，很多场景都是讲的大多数场景不是绝对的场景，具体场景还是需要具体分析，因为Mysql查询机制很优秀会选择“最优执行计划”也和索引的数据结构有关，请读者按着文章实际操作一次，才能更加贴切的了解到索引相关操作的奥秘，光学不写如竹篮打水。</p><a id="more"></a><h2 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h2><p>以下操作都是模拟操作，请自己手动操作一次加深印象</p><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index_name <span class="keyword">on</span> table_name(a,b,c);</span><br><span class="line"><span class="comment"># sql语句</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a=? <span class="keyword">and</span> b = ? <span class="keyword">and</span> c=?;</span><br><span class="line"><span class="comment"># explain查看sql执行状态...</span></span><br></pre></td></tr></table></figure><hr><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>如果索引了多列，要遵循最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p><p>如刚刚创建的索引列为a，b，c。a就是该索引中的最左前列。</p><p>以下将列出几种状况。大家最好都explain看下结果然后理解加深映像。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只查a 走索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = ?;</span><br><span class="line"><span class="comment"># 只查 a,b  走索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a= ? <span class="keyword">and</span> b = ?;</span><br><span class="line"><span class="comment"># 查 a,b,c 走索引 全值匹配中已经列过 略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查b 不走索引 违背了最左前缀原则 最左前列为a</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> b = ?;</span><br><span class="line"><span class="comment"># 查 b,c 不走索引，同只查b</span></span><br><span class="line"><span class="comment"># 只查c 不走索引，同只查b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查 a,c中a走了索引 c没走索引 这里需要配合explain命令key_len字段 发现该查询出的key_len和只查a的ke_len相同，相当于用到的索引长度只用到了a的索引，并没有用到c的索引。 违背最左前缀原则，不允许跳过索引列。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = ? <span class="keyword">and</span> c = ?;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交换顺序查 b,a 走索引 最左前缀原则和查询顺序无关。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> b = ? <span class="keyword">and</span> a = ?;</span><br></pre></td></tr></table></figure><h4 id="最左前缀总结"><a href="#最左前缀总结" class="headerlink" title="最左前缀总结"></a>最左前缀总结</h4><p>联合索引时，建立索引就像是上楼。索引列从左到右，就像从1层爬到n层。人只能一层层的上楼。</p><p>当不包含a列时，就相当于不爬一层楼，直接爬第二层楼，第三层楼，这样是不会走索引的。</p><p>同样查a，c时，爬了一层楼，直接上第三层楼，也是上不上去的，只会用到a的索引。</p><hr><h3 id="使用索引注意事项"><a href="#使用索引注意事项" class="headerlink" title="使用索引注意事项"></a>使用索引注意事项</h3><h4 id="尽量使用覆盖索引"><a href="#尽量使用覆盖索引" class="headerlink" title="尽量使用覆盖索引"></a>尽量使用覆盖索引</h4><p>当使用select *时，就算where的查询符合索引规范，但是实际效率是比 select 索引字段效率低的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 select * 查询 这种方式需要回表查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = ?;</span><br><span class="line"><span class="comment"># 使用 select 索引列字段查询 该种方式就是覆盖索引</span></span><br><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> table_name <span class="keyword">where</span> a = ?;</span><br><span class="line"><span class="comment"># 使用 select 索引字段，加上其他字段 这种方式需要回表查询</span></span><br><span class="line"><span class="keyword">select</span> a,b,c,d <span class="keyword">from</span> table_name <span class="keyword">where</span> a = ?;</span><br></pre></td></tr></table></figure><p>此时用explain主要关注点在extra扩展信息这块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using index : 使用覆盖索引的时候会出现</span><br><span class="line"></span><br><span class="line">using where : 在查找使用索引的情况下，需要回表去查询所需的数据</span><br><span class="line"></span><br><span class="line">using index condition : 查找使用了索引，但是需要回表查询数据</span><br><span class="line"></span><br><span class="line">using index;using where : 查找使用了索引，但是需要的数据都在索引列中能找到，不需要回表查询了</span><br></pre></td></tr></table></figure><p>如果一个索引包含所有需要的查询的字段的值，我们称之为覆盖索引。覆盖索引是非常有用的工具，能够极大的提高性能。因为，只需要读取索引，而无需读表，极大减少数据访问量</p><h4 id="字符串不加单引号"><a href="#字符串不加单引号" class="headerlink" title="字符串不加单引号"></a>字符串不加单引号</h4><p>a的字段为varchar类型</p><p>例如select * from table_name where a = 1</p><p>改成select * from table name where a = ‘1’</p><h4 id="用or分割开的条件"><a href="#用or分割开的条件" class="headerlink" title="用or分割开的条件"></a>用or分割开的条件</h4><p>如果or前的条件中的列有单列索引，不能是复合索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。</p><p>a,b,c的联合索引，d不是索引列，中间是or进行连接是不走索引的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引全部失效</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = ? <span class="keyword">or</span> d = ?;</span><br></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。范围列可以用到索引，但是范围列后面的列无法用到索引。即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引</p><h4 id="like语句的索引问题"><a href="#like语句的索引问题" class="headerlink" title="like语句的索引问题"></a>like语句的索引问题</h4><p>如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀<br>在 like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描</p><p>如果想解决%出现在开头这个问题使<font color="red">覆盖索引</font>来解决这个问题。</p><p>a,b,c的联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用覆盖索引解决</span></span><br><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> table_name <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">'%哈哈%'</span>;</span><br></pre></td></tr></table></figure><h4 id="不要在列上进行运算"><a href="#不要在列上进行运算" class="headerlink" title="不要在列上进行运算"></a>不要在列上进行运算</h4><p>如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描<br>例如 select * from user where YEAR(birthday) &lt; 1990<br>可以改造成 select * from users where birthday &lt;’1990-01-01′</p><h4 id="索引不会包含NULL列"><a href="#索引不会包含NULL列" class="headerlink" title="索引不会包含NULL列"></a>索引不会包含NULL列</h4><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为 NULL</p><h4 id="选择区分度高的列作为索引"><a href="#选择区分度高的列作为索引" class="headerlink" title="选择区分度高的列作为索引"></a>选择区分度高的列作为索引</h4><p>尽量选择区分度高的列作为索引，区分度的公式是<code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。一般需要 join 的字段都要求区分度 0.1 以上，即平均 1 条扫描 10 条记录。</p><h4 id="Mysql不使用索引，全表扫描"><a href="#Mysql不使用索引，全表扫描" class="headerlink" title="Mysql不使用索引，全表扫描"></a>Mysql不使用索引，全表扫描</h4><p>当我们某个字段的值区分度分常低的时候，Mysql底层会判断发现，走了索引和全表扫描性能差距不大，甚至全表扫描速度比走索引还快时，Mysql就不会走索引。</p><p>场景： user表中总共有100条数据，age为索引列，其中age=23的有99条，age=22的有1条。 索引区分度=0.02=2/100。</p><p>因为age=23数据占99%占绝大多数，Mysql不如走全表扫描速度快点。</p><p>age=22占1%，Mysql走索引要快点，所以走索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mysql会判断不走索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当查询age=22的时候走索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><h4 id="IS-NULL-和-IS-NOT-NULL-有时走索引。"><a href="#IS-NULL-和-IS-NOT-NULL-有时走索引。" class="headerlink" title="IS NULL 和 IS NOT NULL 有时走索引。"></a>IS NULL 和 IS NOT NULL 有时走索引。</h4><p>和Mysql不使用索引，全表扫描的原理差不多。</p><p>当NULL值占比很大时，where a is null 不走索引全表扫描。is not null大概率会走索引，具体要看占数据比例。Mysql会自己判断。</p><p>当NOT NULL值占比大时，where a is not null不走索引全表扫描。is null 大概率会走索引，具体看占数据比例。Mysql会自己判断。</p><h4 id="in-走索引-not-in-有时不走索引"><a href="#in-走索引-not-in-有时不走索引" class="headerlink" title="in 走索引 not in 有时不走索引"></a>in 走索引 not in 有时不走索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 走索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment"># 不走索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这时我们在实际查询中发现怎么not in也走索引了？</p><p>具体问题还是要具体分析的。</p><p>因为在很多场景下，NOT IN或&lt;&gt;两类操作使用二级索引的成本远超于全表扫描的成本，查询优化器按照成本选择”最优执行计划”，导致查询不走二级索引。但不能因此就彻底判断NOT IN或&lt;&gt;两类操作不能走索引。</p><hr><h3 id="单列索引和复合索引的选择"><a href="#单列索引和复合索引的选择" class="headerlink" title="单列索引和复合索引的选择"></a>单列索引和复合索引的选择</h3><p>尽量使用复合索引，<font color="red">少使用或尽量不用单列索引</font></p><p>创建复合索引就相当于创建了三个索引</p><p>例如复合索引a,b,c 创建了如下三个索引</p><ol><li>a</li><li>a + b</li><li>a + b + c</li></ol><p>如果创建了3个单列索引，Mysql会选择最优的一个索引使用，不会用到全部索引。</p><p>Mysql怎么去选择最优索引呢？ 这涉及到上面说的选择区分度高的字段加索引。区分度越高的索引查询出的数据越少，查询速度越快。</p><p>以下讲解几种情况。</p><p>场景：表中两个字段有单列索引 name和mobile 表中10条数据。 </p><p>name有5条数据都为’测试’，其余的数据都不相同。</p><p>mobile有9条数据都为’12345678901’，剩下一条为’12345678902’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个和最左前缀原则无关，因为都是单列索引 最终选择了name的索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'测试'</span> <span class="keyword">and</span> mobile = <span class="string">'12345678901'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当mobile='12345678902' 最终选择mobile索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'测试'</span> <span class="keyword">and</span> mobile = <span class="string">'12345678902'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前会话的索引使用情况</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Handler_read_first    | 0     |</span><br><span class="line">| Handler_read_key      | 0     |</span><br><span class="line">| Handler_read_next     | 0     |</span><br><span class="line">| Handler_read_prev     | 0     |</span><br><span class="line">| Handler_read_rnd      | 0     |</span><br><span class="line">| Handler_read_rnd_next | 74    |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看全局的索引使用情况</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;</span><br><span class="line">+<span class="comment">-----------------------+--------------+</span></span><br><span class="line">| Variable_name         | Value        |</span><br><span class="line">+<span class="comment">-----------------------+--------------+</span></span><br><span class="line">| Handler_read_first    | 1785153      |</span><br><span class="line">| Handler_read_key      | 2650399364   |</span><br><span class="line">| Handler_read_next     | 104781425    |</span><br><span class="line">| Handler_read_prev     | 55082598     |</span><br><span class="line">| Handler_read_rnd      | 14893605     |</span><br><span class="line">| Handler_read_rnd_next | 244848860571 |</span><br><span class="line">+<span class="comment">-----------------------+--------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>分析这几个值，我们可以查看当前索引的使用情况：</p><h4 id="Handler-read-first："><a href="#Handler-read-first：" class="headerlink" title="Handler_read_first："></a>Handler_read_first：</h4><p>索引中第一条被读的次数。如果较高，它表示服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引（这个值越低越好）。</p><h4 id="Handler-read-key："><a href="#Handler-read-key：" class="headerlink" title="Handler_read_key："></a>Handler_read_key：</h4><p>如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。</p><h4 id="Handler-read-next-："><a href="#Handler-read-next-：" class="headerlink" title="Handler_read_next ："></a>Handler_read_next ：</h4><p>按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</p><h4 id="Handler-read-prev："><a href="#Handler-read-prev：" class="headerlink" title="Handler_read_prev："></a>Handler_read_prev：</h4><p>按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</p><h4 id="Handler-read-rnd-："><a href="#Handler-read-rnd-：" class="headerlink" title="Handler_read_rnd ："></a>Handler_read_rnd ：</h4><p>根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。</p><h4 id="Handler-read-rnd-next："><a href="#Handler-read-rnd-next：" class="headerlink" title="Handler_read_rnd_next："></a>Handler_read_rnd_next：</h4><p>在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</p><hr><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h2><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p><h3 id="对一张表插入很多行数据时"><a href="#对一张表插入很多行数据时" class="headerlink" title="对一张表插入很多行数据时"></a>对一张表插入很多行数据时</h3><p>尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接，关闭等消耗。使得效率比分开执行的单个insert语句快。</p><p>原始方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'2'</span>,<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'3'</span>,<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><p>优化后方案：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'a'</span>),(<span class="string">'2'</span>,<span class="string">'b'</span>),(<span class="string">'3'</span>,<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><h3 id="在事务中进行数据插入"><a href="#在事务中进行数据插入" class="headerlink" title="在事务中进行数据插入"></a>在事务中进行数据插入</h3><p>减少多次自动提交事务的连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'2'</span>,<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'3'</span>,<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h3 id="数据主键有序插入"><a href="#数据主键有序插入" class="headerlink" title="数据主键有序插入"></a>数据主键有序插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下是无序的</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'2'</span>,<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(<span class="string">'3'</span>,<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="优化order-by-语句"><a href="#优化order-by-语句" class="headerlink" title="优化order by 语句"></a>优化order by 语句</h2><p>explain查看执行计划的extra，using index效率最高 using filesort效率低</p><ol><li>首先order by的字段必须都是有索引的，其次要使用覆盖索引返回，不然会using filesort效率低</li><li>order by的顺序和联合索引的顺序必须相同</li><li>order by的字段要么都是升序，要么都是降序</li></ol><h3 id="filesort优化"><a href="#filesort优化" class="headerlink" title="filesort优化"></a>filesort优化</h3><p>当我们无法避免filesort优化时，还是需要对filesort进行优化</p><h4 id="两种排序方式"><a href="#两种排序方式" class="headerlink" title="两种排序方式"></a>两种排序方式</h4><ol><li>两次扫描算法：MySQL 4.1之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区sort buff中排序，如果sort buff不够，则在临时表temporary table中存储排序结果。完成排序后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</li><li>一次扫描算法：一次性去除满足条件的字段，然后在排序区sort buff中排序后直接输出结果集。排序内存开销大，但是排序效率比两次扫描算法高。</li></ol><h4 id="具体优化方式"><a href="#具体优化方式" class="headerlink" title="具体优化方式"></a>具体优化方式</h4><p>MySQL通过比较系统变量max_length_for_sort_data的大小和Query语句取出的字段总大小，来判定是否哪种排序方法，如果max_length_for_sort_data更大，那么使用第二种优化之后的算法；否则使用第一种。</p><p>可以适当提高max_length_for_sort_data和sort_buffer_size系统变量，来增大排序区的大小，提高排序效率。</p><hr><h2 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h2><p>由于Group By实际上同样会进行排序操作，而且与ORDER BY相比，GROUP BY主要是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以在GROUP BY的实现过程中，与ORDER BY一样也可以利用到索引。</p><ol><li><p>如果查询包含group by但是用户想要避免排序结果的消耗，则可以执行order by null禁止排序。如下：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样执行 explain时 extra会提示using filesort</span></span><br><span class="line"><span class="keyword">select</span> age, <span class="keyword">count</span>(*) <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化后</span></span><br><span class="line"><span class="keyword">select</span> age, <span class="keyword">count</span>(*) <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建对应字段的索引来提高group by的效率</p></li></ol><hr><h2 id="优化嵌套查询"><a href="#优化嵌套查询" class="headerlink" title="优化嵌套查询"></a>优化嵌套查询</h2><p>MySQL4.1之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另外一个查询当中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，而且写起来很容易。但是，有些情况下，子查询时可以被更高效的连接（JOIN）替代。</p><hr><h2 id="优化OR条件"><a href="#优化OR条件" class="headerlink" title="优化OR条件"></a>优化OR条件</h2><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引，而且不能使用到复合索引；如果没有索引，则应该考虑增加索引。</p><p>建议使用union替换or</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换前 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">or</span> b = <span class="string">'测试'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用union 优化</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> b = <span class="string">'测试'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用union替换后可以发现相比or explain出来后 or 的type为range union的为两个效率更好的type</span></span><br></pre></td></tr></table></figure><hr><h2 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h2><p>一般分页查询时，通过创建覆盖索引能够比较好的提高性能。一个常见又非常头疼的问题就是limit 2000000,10 </p><p>此时需要MySQL排序前2000010条记录，仅仅返回2000000-2000010的记录，其记录丢弃，查询排序的代价非常大。</p><h3 id="优化思路一"><a href="#优化思路一" class="headerlink" title="优化思路一"></a>优化思路一</h3><p>在索引上完成排序分页操作，最后根据主键关联回原标查询所需要的其他列内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name t0,(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>) t1 <span class="keyword">where</span> t0.id = t1.id;</span><br></pre></td></tr></table></figure><h3 id="优化思路二"><a href="#优化思路二" class="headerlink" title="优化思路二"></a>优化思路二</h3><p>该方案适用于主键自增的表（不能出现id断层，也不能出现其他条件查询），可以把limit查询转换成某个位置的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">2000000</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h2><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><h3 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h3><p>在查询语句表明的后面，添加use index来提供希望MySQL去参考（仅仅是一个参考，并不是强制性的，最终选择还是看Mysql选择的最优查询方案）的索引表，就可以让MySQL不再考虑其他可用索引</p><p>当explain查看执行计划时，possible_keys有多个时可以使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">use</span> <span class="keyword">index</span>(index_name);</span><br></pre></td></tr></table></figure><h3 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h3><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">ignore</span> <span class="keyword">index</span>(index_name);</span><br></pre></td></tr></table></figure><h3 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h3><p>为强制MySQL使用一个特定的索引，可在查询中使用force index。因为use index只是一个参考，当Mysql判断参考的查询索引不够快时，会选择其他索引查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">force</span> <span class="keyword">index</span>(index_name);</span><br></pre></td></tr></table></figure><h1 id="放在最后"><a href="#放在最后" class="headerlink" title="放在最后"></a>放在最后</h1><p>本文根据学习B站<a href="https://www.bilibili.com/video/BV1UQ4y1P7Xr?p=47" target="_blank" rel="noopener"><font color="0099ff">【黑马程序员】2020最新MySQL高级教程（求职面试必备）</font></a>p47-p66整理笔记，有需要的同学可以前去系统的学习。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> sql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说你不想只搬砖？——Mysql中sql优化步骤</title>
      <link href="/%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B8%8D%E6%83%B3%E5%8F%AA%E6%90%AC%E7%A0%96%EF%BC%9F%E2%80%94%E2%80%94Mysql%E4%B8%ADsql%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4.html"/>
      <url>/%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B8%8D%E6%83%B3%E5%8F%AA%E6%90%AC%E7%A0%96%EF%BC%9F%E2%80%94%E2%80%94Mysql%E4%B8%ADsql%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4.html</url>
      
        <content type="html"><![CDATA[<h1 id="优化SQL步骤"><a href="#优化SQL步骤" class="headerlink" title="优化SQL步骤"></a>优化SQL步骤</h1><p>听说你不想在工作中只做一些简单的CRUD的工作了。</p><p>那么作为极客的你，一定得知道这些优化SQL的步骤，才能在大数据级表查询中不用注释掉Thread.sleep(10000);就能让你的程序优化杠杠的。</p><h2 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h2><h3 id="查看当前连接的信息"><a href="#查看当前连接的信息" class="headerlink" title="查看当前连接的信息"></a>查看当前连接的信息</h3> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看SQL执行频率 7个_占位 查询的是当前连接的信息 此处代表命令执行操作次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>;</span><br><span class="line"><span class="comment"># 以下是查询出的信息</span></span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Com_binlog    | 0     |</span><br><span class="line">| Com_commit    | 0     |</span><br><span class="line">| Com_delete    | 0     |</span><br><span class="line">| Com_import    | 0     |</span><br><span class="line">| Com_insert    | 0     |</span><br><span class="line">| Com_repair    | 0     |</span><br><span class="line">| Com_revoke    | 0     |</span><br><span class="line">| Com_select    | 1     |</span><br><span class="line">| Com_signal    | 0     |</span><br><span class="line">| Com_update    | 0     |</span><br><span class="line">| Com_xa_end    | 0     |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">11 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="查看全局的连接信息"><a href="#查看全局的连接信息" class="headerlink" title="查看全局的连接信息"></a>查看全局的连接信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 查看全局的SQL执行频率 此处代表命令执行操作次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>;</span><br><span class="line"><span class="comment">### 以下是查询出的信息</span></span><br><span class="line">+<span class="comment">---------------+--------+</span></span><br><span class="line">| Variable_name | Value  |</span><br><span class="line">+<span class="comment">---------------+--------+</span></span><br><span class="line">| Com_binlog    | 0      |</span><br><span class="line">| Com_commit    | 3515   |</span><br><span class="line">| Com_delete    | 95     |</span><br><span class="line">| Com_import    | 0      |</span><br><span class="line">| Com_insert    | 18088  |</span><br><span class="line">| Com_repair    | 0      |</span><br><span class="line">| Com_revoke    | 0      |</span><br><span class="line">| Com_select    | 101830 |</span><br><span class="line">| Com_signal    | 0      |</span><br><span class="line">| Com_update    | 21820  |</span><br><span class="line">| Com_xa_end    | 0      |</span><br><span class="line">+<span class="comment">---------------+--------+</span></span><br><span class="line">11 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="查看InnoDB表的SQL执行频率"><a href="#查看InnoDB表的SQL执行频率" class="headerlink" title="查看InnoDB表的SQL执行频率"></a>查看InnoDB表的SQL执行频率</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看InnoDB表的SQL执行频率 此处的value代表影响的行数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Innodb_rows_%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 以下是返回信息</span></span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| Variable_name        | Value    |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| Innodb_rows_deleted  | 865      |</span><br><span class="line">| Innodb_rows_inserted | 3287391  |</span><br><span class="line">| Innodb_rows_read     | 37754591 |</span><br><span class="line">| Innodb_rows_updated  | 7009     |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="show-status字段详解"><a href="#show-status字段详解" class="headerlink" title="show status字段详解"></a>show status字段详解</h3><p>具体的Variable_name字段各种值代码的意义推荐阅读<a href="https://blog.csdn.net/zhaowenbo168/article/details/53199585" target="_blank" rel="noopener"><font color="0099ff">MySQL运行状态show status详解</font></a></p><a id="more"></a><h2 id="定位低效率执行SQL"><a href="#定位低效率执行SQL" class="headerlink" title="定位低效率执行SQL"></a>定位低效率执行SQL</h2><p>可以通过以下两种方式定位执行效率较低的SQL语句</p><ul><li>慢查询日志：通过慢查询日志定位哪些执行效率较低的SQL语句，用–log-slow-queries[=file_name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。</li><li>show processlist：慢查询日志在查询结束后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist;命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时的查看SQL的执行情况，同时对一些锁表的操作进行优化。注意，如果执行完成的语句是查询不出来的。<font color="red">当一不小心执行了一个相当慢的查询锁表了，就可以<code>show processlist;</code>查出进程id，kill掉。</font>，趁还没被老板diss的时候先发制人</li></ul><table><thead><tr><th>字段名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>用户登陆Mysql时，系统分配的”connection_id”，可以使用函数connection_id()查看</td></tr><tr><td>user</td><td>显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</td></tr><tr><td>host</td><td>显示这个语句是从哪个ip的端口上发的，可以用来跟踪出现问题语句的用户</td></tr><tr><td>db</td><td>显示这个进程目前连接的是哪个数据库</td></tr><tr><td>command</td><td>显示当前连接的执行的命令，一般取值休眠（sleep），查询（Query），连接（Connect）等</td></tr><tr><td>time</td><td>显示这个状态的持续时间，单位是秒</td></tr><tr><td>State</td><td>显示使用当前连接sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态，一个sql语句，查询为例，可能需要经过 copy to tmp table、sorting result、sending data等状态才可以完成</td></tr></tbody></table><h2 id="explain分析执行计划"><a href="#explain分析执行计划" class="headerlink" title="explain分析执行计划"></a>explain分析执行计划</h2><p>通过以上步骤查询到的效率低的SQL语句后，可以通过Explain或者DESC命令获取MySQL如何执行SELECT语句的信息，包括SELECT语句执行过程中表如何连接，和连接的顺序。</p><p>查询SQL语句的执行计划：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from patient;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，是一组数字，表示是查询中执行select子句或是操作表的顺序</td></tr><tr><td>select_type</td><td>表示SELECT类型，常见的取值有SIMPLE（简单表，不使用表连接或子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示表的连接类型，性能由好到差的连接类型为（<font color="red">system &gt; const &gt; eq_ef &gt; ref &gt; ref_or_null &gt; index_merge &gt; index_subquery &gt; range &gt; index &gt; all</font>）</td></tr><tr><td>possible_keys</td><td>表查询时，可能使用的索引</td></tr><tr><td>key</td><td>表实际使用的索引</td></tr><tr><td>key_leng</td><td>索引字段长度</td></tr><tr><td>ref</td><td>显示索引的哪一列被使用了，如果可能的话，是一个常数</td></tr><tr><td>rows</td><td>扫描行的数量</td></tr><tr><td>filtered</td><td>表示此查询条件所过滤的数据的百分比</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><h3 id="explain中的id"><a href="#explain中的id" class="headerlink" title="explain中的id"></a>explain中的id</h3><ol><li>id相同表示加载顺序从上到下，普通的关联查询</li><li>id不同id值越大，优先级越高，越先被执行。包含子查询时</li><li>id有不同，也有相同。 先执行id大的，然后相同id的加载顺序从上到下。例如：form子查询时，再做关联</li></ol><h3 id="explain中的select-type"><a href="#explain中的select-type" class="headerlink" title="explain中的select_type"></a>explain中的select_type</h3><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂子查询，最外层查询标记为该标识</td></tr><tr><td>SUBQUERY</td><td>在SELECT或者WHERE列表中的子查询</td></tr><tr><td>DERIVED</td><td>在FROM列表中包含的子查询，被标记为DERIVED（衍生）MYSQL会执行这些子查询，把结果放在临时表中 </br>例如</br>explain select a.* from (select * from user where id in (1,2)) a;</td></tr><tr><td>UNION</td><td>若第二个SELECT出现UNION之后，则标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><h3 id="explain中的type"><a href="#explain中的type" class="headerlink" title="explain中的type"></a>explain中的type</h3><p> type显示的是访问类型，是较为重要的指标，可取值为：</p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>MYSQL不访问任何表，索引，直接返回结果</td></tr><tr><td>system</td><td>表只有一行记录（等于系统表），这是const类型的特例，一般不会出现</td></tr><tr><td>const</td><td>表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如果将主键用于where查询，MYSQL就能很将该查询转换为一个常量。const于将<code>主键</code>或<code>唯一</code>索引的所有部分与常量值进行比较。</td></tr><tr><td>eq_ref</td><td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描。</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td></tr><tr><td>range</td><td>只检索给定返回的行，使用一个索引来选择行。where之后出现between，&lt;，&gt;，in等操作</td></tr><tr><td>index</td><td>index与ALL的区别为index类型只是遍历了索引树，通常比all快，all是遍历数据文件。例如只查询出某个有索引的字段。</td></tr><tr><td>all</td><td>将遍历全表以找到匹配的行</td></tr></tbody></table><h3 id="explain中的key"><a href="#explain中的key" class="headerlink" title="explain中的key"></a>explain中的key</h3><ol><li>possible_keys ：显示可能应用在这张表的索引，一个或多个</li><li>key：实际使用的索引，如果为Null，则没有使用索引。</li><li>key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li></ol><h3 id="explain中rows"><a href="#explain中rows" class="headerlink" title="explain中rows"></a>explain中rows</h3><p>扫描的行数</p><h3 id="explain中的extra"><a href="#explain中的extra" class="headerlink" title="explain中的extra"></a>explain中的extra</h3><p>其他的额外的执行计划信息，在该列展示。</p><table><thead><tr><th>extra</th><th>含义</th></tr></thead><tbody><tr><td>using filesort</td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，称为“文件排序”</td></tr><tr><td>using temporary</td><td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于order by和group by</td></tr><tr><td>using index</td><td>表示相应的select操作使用了覆盖索引，避免访问表的数据行，效率不错。</td></tr></tbody></table><h2 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h2><p>Mysql从5.037版本开始增加了对show profile语句的支持。show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><p>通过select @@have_profiling命令，能够看到当前MySQL是否支持profile：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@have_profiling;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| @@have_profiling |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| YES              |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询是否开启profiling 结果0代表关闭</span></span><br><span class="line">mysql&gt; select @@profiling</span><br><span class="line">    -&gt; ;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| @@profiling |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           0 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置profiling=1开启</span></span><br><span class="line">mysql&gt; <span class="keyword">set</span> profiling=<span class="number">1</span></span><br><span class="line">    -&gt; ;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询出来就是开启状态了</span></span><br><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| @@profiling |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           1 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>通过profile，能更清楚地了解SQL执行的过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询最近命令的耗时</span></span><br><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="comment">----------+------------+------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                        |</span><br><span class="line">+<span class="comment">----------+------------+------------------------------+</span></span><br><span class="line">|        1 | 0.00022575 | <span class="keyword">select</span> @@profiling           |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00012400</span> | <span class="keyword">select</span> * <span class="keyword">from</span> patient        |</span><br><span class="line">|        <span class="number">3</span> | <span class="number">0.00023025</span> | <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>()            |</span><br><span class="line">|        <span class="number">4</span> | <span class="number">0.00083125</span> | <span class="keyword">show</span> <span class="keyword">databases</span>               |</span><br><span class="line">|        <span class="number">5</span> | <span class="number">0.00118525</span> | <span class="keyword">show</span> <span class="keyword">tables</span>                  |</span><br><span class="line">|        <span class="number">6</span> | <span class="number">0.01512725</span> | <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> patient |</span><br><span class="line">|        <span class="number">7</span> | <span class="number">0.04421450</span> | <span class="keyword">select</span> * <span class="keyword">from</span> patient        |</span><br><span class="line">+<span class="comment">----------+------------+------------------------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>当我们查出了最近命令耗时后还可以通过 show profile for query 查询出的query_id; 查询命令具体各个阶段的耗时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 7;</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line">| Status                         | Duration |</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line">| starting                       | 0.000081 |</span><br><span class="line">| Executing hook on transaction  | 0.000008 |</span><br><span class="line">| starting                       | 0.000012 |</span><br><span class="line">| checking permissions           | 0.000009 |</span><br><span class="line">| Opening tables                 | 0.000055 |</span><br><span class="line">| init                           | 0.000009 |</span><br><span class="line">| System <span class="keyword">lock</span>                    | <span class="number">0.000018</span> |</span><br><span class="line">| optimizing                     | <span class="number">0.000006</span> |</span><br><span class="line">| <span class="keyword">statistics</span>                     | <span class="number">0.000021</span> |</span><br><span class="line">| preparing                      | <span class="number">0.000019</span> |</span><br><span class="line">| executing                      | <span class="number">0.043880</span> |</span><br><span class="line">| <span class="keyword">end</span>                            | <span class="number">0.000026</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>                      | <span class="number">0.000007</span> |</span><br><span class="line">| waiting <span class="keyword">for</span> <span class="keyword">handler</span> <span class="keyword">commit</span>     | <span class="number">0.000014</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>                 | <span class="number">0.000013</span> |</span><br><span class="line">| freeing items                  | <span class="number">0.000022</span> |</span><br><span class="line">| cleaning up                    | <span class="number">0.000018</span> |</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="number">17</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>查看所有信息<code>show profile all for query 7;</code></p><h2 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h2><p>MySQL5.6提供了对SQL的跟中trace，通过trace文件能够进一步了解为什么优化器选择A计划，而不是B计划。</p><p>打开trace，设置格式为JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存太小而不能够完整的展示。</p><p>有兴趣的朋友可以点击相关链接学习了解，或者百度大法好～</p><p>相关链接：<a href="https://blog.csdn.net/taojin12/article/details/81489234" target="_blank" rel="noopener"><font color="0099ff">通过trace分析优化器如何选择执行计划</font></a></p><h1 id="放在最后"><a href="#放在最后" class="headerlink" title="放在最后"></a>放在最后</h1><p>本文根据学习B站<a href="https://www.bilibili.com/video/BV1UQ4y1P7Xr?p=38" target="_blank" rel="noopener"><font color="0099ff">【黑马程序员】2020最新MySQL高级教程（求职面试必备）</font></a>p38-p46整理笔记，有需要的同学可以前去系统的学习。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> sql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql存储引擎</title>
      <link href="/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"/>
      <url>/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h1><p>和大多数的数据库不同，MySQL中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎。</p><p>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。</p><p>Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应的引擎，或者编写存储引擎。</p><a id="more"></a><p>MySQL5.0支持的存储引擎包含：</p><ul><li>InnoDB</li><li>MyISAM</li><li>BDB</li><li>MEMORY</li><li>MERGE</li><li>EXAMPLE</li><li>NDB Cluster</li><li>ARCHIVE</li><li>CSV</li><li>BLACKHOLE</li><li>REDERATED</li></ul><p>其中InnoDB和BDB提供事务安全表，其他存储引擎都是非事务安全表。</p><p>可以通过指定下面语句，来查询当前数据库支持的存储引擎。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure><p>查看默认引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure><h1 id="各种存储引擎特性"><a href="#各种存储引擎特性" class="headerlink" title="各种存储引擎特性"></a>各种存储引擎特性</h1><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td><strong>存储限制</strong></td><td>64TB</td><td>有</td><td>有</td><td>没有</td><td>有</td></tr><tr><td><strong>事务安全</strong></td><td><font color="red"><strong>支持</strong></font></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>锁机制</strong></td><td><strong><font color="red">行锁（适合高并发）</font></strong></td><td><font color="red"><strong>表锁</strong></font></td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td><strong>B树索引</strong></td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td><strong>哈希索引</strong></td><td></td><td></td><td>支持</td><td></td><td></td></tr><tr><td><strong>全文索引</strong></td><td>支持（5.6版本之后）</td><td>支持</td><td></td><td></td><td></td></tr><tr><td><strong>集群索引</strong></td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>数据索引</strong></td><td>支持</td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td><strong>索引缓存</strong></td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td><strong>数据可压缩</strong></td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td><strong>空间使用</strong></td><td>高</td><td>低</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td><strong>内存使用</strong></td><td>高</td><td>低</td><td>中等</td><td>低</td><td>低</td></tr><tr><td><strong>批量插入速度</strong></td><td>低</td><td>高</td><td>高</td><td>高</td><td>高</td></tr><tr><td><strong>支持外键</strong></td><td><font color="red"><strong>支持</strong></font></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>这里重点要掌握InnoDB/MyISAM，另外三种了解就行。</p><p>其中不管什么引擎表存储在磁盘上的linux文件路径都为<code>/var/lib/mysql</code>路径下。该目录下根据数据库名分文件夹，进入文件夹后下方是根据表名存储的不同文件。</p><p><font color="red">注意：在MySQL8开始删除了原来的frm文件，并采用 Serialized Dictionary Information (SDI), 是MySQL8.0重新设计数据词典后引入的新产物,并开始已经统一使用InnoDB存储引擎来存储表的元数据信息。SDI信息源记录保存在ibd文件中。<br>如何可以查看表结构信息，官方提供了一个工具叫做ibd2sdi，在安装目录下可以找到，可以离线的将ibd文件中的冗余存储的sdi信息提取出来，并以json的格式输出到终端。</font></p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="comment"># 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment"># 回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>重点外键功能</p><pre><code>- ON DELETE RESTRICT 当从表中有用到该外键的数据时，主表不能删除该对应的数据- ON UPDATE CASCADE 当主表修改了该外键某行该字段的值，从表关联的值也同时做修改</code></pre><h3 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h3><p>InnoDB存储表和索引有以下两种存储方式：</p><ol><li>使用共享表空间存储，这种方式创建的表的表结构保存在<code>表名.frm</code>文件中，数据和索引保存在<code>innodb_data_home_dir</code>和<code>innodb_data_file_path</code>定义的表空间中，可以时多个文件</li><li>使用多表空间存储，这种方式创建的表结构仍然存储在<code>表名.frm</code>文件中，但是每个表的数据和索引单独保存在<code>表名.ibd</code>文件中</li></ol><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>​    MyISAM不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表。</p><h3 id="不支持事务"><a href="#不支持事务" class="headerlink" title="不支持事务"></a>不支持事务</h3><p>不管如何<code>start transaction;commit;rollback;</code>都无法操作事务</p><h3 id="文件存储方式"><a href="#文件存储方式" class="headerlink" title="文件存储方式"></a>文件存储方式</h3><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但扩展名分别是:</p><ul><li>.frm（存储表定义）</li><li>.MYD（MYData，存储表数据）</li><li>.MYI（MYIndex，存储表索引）</li></ul><h2 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h2><p>Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY类型的表访问非常的快，因为他的数据是存放在内存中的，并且默认使用HASH索引，但是服务一旦关闭，表中的数据就会丢失。</p><h2 id="MERGE"><a href="#MERGE" class="headerlink" title="MERGE"></a>MERGE</h2><p>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p><p>对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST或LAST值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。</p><p>可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响。</p><p>可以理解MERGE存储引擎类型的表，将数据结构相同的MyISAM表union all关联起来的视图，只是视图不能条件筛选，但是merge存储引擎的表可以通过where进行条件筛选</p><h3 id="创建MERGE存储引擎的表"><a href="#创建MERGE存储引擎的表" class="headerlink" title="创建MERGE存储引擎的表"></a>创建MERGE存储引擎的表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 省略创建 user_01，user_02 engine为myisam的表</span></span><br><span class="line"><span class="comment"># 创建 engine为merge的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_all (</span><br><span class="line"><span class="comment">#user_01,user_02两张表相同的表结构</span></span><br><span class="line">)<span class="keyword">engine</span> = <span class="keyword">merge</span> <span class="keyword">union</span> = (user_01,user_02) INSERT_METHOD=<span class="keyword">LAST</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="分别向两张表中插入记录"><a href="#分别向两张表中插入记录" class="headerlink" title="分别向两张表中插入记录"></a>分别向两张表中插入记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_01 <span class="keyword">values</span>();</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_01 <span class="keyword">values</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_02 <span class="keyword">values</span>();</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_02 <span class="keyword">values</span>();</span><br></pre></td></tr></table></figure><h1 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h1><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用程序，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p><ul><li>InnoDB：对事务业务要求较高，更新、删除操作频繁。对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li><li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高，那么选择MyISAM是非常合适的。</li><li>MEMORY：通常用于更新不频繁的表，用以快速得到访问结果，现在更多是用NoSQL替代了如redis、MongoDB</li><li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破MyISAM表的限制大小，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓库等环境十分合适。个人认为对于数据量大而分表的数据也可以用MERGE来合并查询。</li></ul><h1 id="放在最后"><a href="#放在最后" class="headerlink" title="放在最后"></a>放在最后</h1><p>本文根据学习B站<a href="https://www.bilibili.com/video/BV1UQ4y1P7Xr?p=32" target="_blank" rel="noopener"><font color="0099ff">【黑马程序员】2020最新MySQL高级教程（求职面试必备）</font></a>p32-p36整理笔记，有需要的同学可以前去系统的学习。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 存储引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引</title>
      <link href="/Mysql%E7%B4%A2%E5%BC%95.html"/>
      <url>/Mysql%E7%B4%A2%E5%BC%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h1><p>MySQL官方堆索引的定义为：索引（index）是帮助<font color="red">MySQL高效获取数据</font>的<font color="red">数据结构</font>（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><a id="more"></a><h1 id="索引优势劣势"><a href="#索引优势劣势" class="headerlink" title="索引优势劣势"></a>索引优势劣势</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>类似数据的目录索引，提高数据检索的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗</li></ol><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol><li>实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</li><li>虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新带来的键值变化后的索引信息。</li></ol><h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li><p>BTREE索引：最常见的索引类型，大部分索引都支持B树索引。</p></li><li><p>HASH索引：只有Memory引擎支持，使用场景简单。</p></li><li><p>R-tree索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。</p></li><li><p>Full-text（全文索引）：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</p><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td><font color="green">支持</font></td><td><font color="green">支持</font></td><td><font color="green">支持</font></td></tr><tr><td>HASH索引</td><td><font color="red">不支持</font></td><td><font color="red">不支持</font></td><td><font color="green">支持</font></td></tr><tr><td>R-tree索引</td><td><font color="red">不支持</font></td><td><font color="green">支持</font></td><td><font color="red">不支持</font></td></tr><tr><td>Full-text</td><td><font color="green">5.6版本后支持</font></td><td><font color="green">支持</font></td><td><font color="red">不支持</font></td></tr></tbody></table></li></ul><p>我们平常所说的索引，如果没有特别之名，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用B+tree索引，统称为索引。</p><h2 id="BTREE结构"><a href="#BTREE结构" class="headerlink" title="BTREE结构"></a>BTREE结构</h2><p>BTree又叫多路平衡搜索树，一颗m叉（可以有m个子节点）的BTree特性如下：</p><ul><li>树中每个节点最多包含m个子节点</li><li>除根节点与叶子节点外，每个节点至少有[ceil(m/2)] (m/2向上取整)个子节点</li><li>若根节点不是叶子节点，则至少有两个子节点。</li><li>所有叶子节点都在同一层</li><li>每个非叶子节点有n个key与n+1个指针组成，其中 [ceil(m/2)-1] &lt;= n &lt;= m-1</li></ul><p>BTree树和二叉树相比，查询数据的效率更高，因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度更快。</p><p>点击查看数据结构演变过程讲解<a href="https://www.bilibili.com/video/BV1UQ4y1P7Xr?p=6" target="_blank" rel="noopener"><font color="0099ff">BTree数据结构5叉为例讲解</font></a></p><h2 id="B-TREE结构"><a href="#B-TREE结构" class="headerlink" title="B+TREE结构"></a>B+TREE结构</h2><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p><ol><li>n叉B+Tree最多包含n个key，而BTree最多包含n-1个key</li><li>B+Tree的叶子节点保存所有的Key信息，依key大小排序</li><li>所有的非叶子节点都可以看作是key的索引部分。</li></ol><p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子节点。所以B+Tree查询效率更加稳定。</p><h2 id="MySQL中的B-Tree"><a href="#MySQL中的B-Tree" class="headerlink" title="MySQL中的B+Tree"></a>MySQL中的B+Tree</h2><p>MySQL索引数据结构对经典的B+Tree进行了优化，在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p>点击查看<a href="https://www.bilibili.com/video/BV1UQ4y1P7Xr?p=7" target="_blank" rel="noopener"><font color="0099ff">B+Tree和Mysql中的B+Tree</font></a></p><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ol><li>单值索引（单列索引）：就是一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引：即一个索引包含多个列</li></ol><h1 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建索引 其中index_type为空时使用的索引类型为BTree</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>|FULLTEXT|SPATIAL] <span class="keyword">INDEX</span> index_name [<span class="keyword">USING</span> index_type] <span class="keyword">on</span> table_name(index_col_name,...);</span><br></pre></td></tr></table></figure><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name;</span><br><span class="line"><span class="comment"># 查看不方便时在末尾加\G 这种方式只能在mysql命令行时使用</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name\G;</span><br></pre></td></tr></table></figure><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除索引 索引名 在 表名中;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="ALTER命令"><a href="#ALTER命令" class="headerlink" title="ALTER命令"></a>ALTER命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增一个主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span>(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一个唯一索引（除NULL外，NULL可能会出现多次）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一个普通索引，索引值可能会出现多次</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个索引为FULLTEXT，用于全文索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> fulltext index_name(column_list);</span><br></pre></td></tr></table></figure><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p><ul><li>对查询频次较高，且数据量比较大的表建立索引</li><li>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列组合。</li><li>使用唯一索引，区分度越高，使用索引的效率越高</li><li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然越高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难症，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</li><li>使用短索引，索引创建之后也是使用硬盘来存储，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。</li><li>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建复合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name_email_status <span class="keyword">ON</span> table_name(<span class="string">`name`</span>,email,<span class="string">`status`</span>);</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="comment"># 对name 创建索引</span></span><br><span class="line"><span class="comment"># 对name,email 创建索引</span></span><br><span class="line"><span class="comment"># 对name,email,status 创建索引</span></span><br></pre></td></tr></table></figure><hr><h1 id="放在最后"><a href="#放在最后" class="headerlink" title="放在最后"></a>放在最后</h1><p>本文根据学习B站<a href="https://www.bilibili.com/video/BV1UQ4y1P7Xr?p=3" target="_blank" rel="noopener"><font color="0099ff">【黑马程序员】2020最新MySQL高级教程（求职面试必备）</font></a>p3-p10整理笔记，有需要的同学可以前去系统的学习。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中MyISAM和InnoDB区别</title>
      <link href="/Mysql%E4%B8%ADMyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB.html"/>
      <url>/Mysql%E4%B8%ADMyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h1><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h1><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p><a id="more"></a><h1 id="MyISAM与InnoDB的区别是什么？"><a href="#MyISAM与InnoDB的区别是什么？" class="headerlink" title="MyISAM与InnoDB的区别是什么？"></a><strong>MyISAM与InnoDB的区别是什么？</strong></h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a><strong>存储结构</strong></h2><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h2 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a><strong>存储空间</strong></h2><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。<br>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><h2 id="可移植性、备份及恢复"><a href="#可移植性、备份及恢复" class="headerlink" title="可移植性、备份及恢复"></a><strong>可移植性、备份及恢复</strong></h2><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a><strong>事务支持</strong></h2><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a><strong>AUTO_INCREMENT</strong></h2><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h2 id="表锁差异"><a href="#表锁差异" class="headerlink" title="表锁差异"></a><strong>表锁差异</strong></h2><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a><strong>全文索引</strong></h2><p>MyISAM：支持 FULLTEXT类型的全文索引<br>InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><h2 id="表主键"><a href="#表主键" class="headerlink" title="表主键"></a><strong>表主键</strong></h2><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p><h2 id="表的具体行数"><a href="#表的具体行数" class="headerlink" title="表的具体行数"></a><strong>表的具体行数</strong></h2><p>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h2 id="CURD操作"><a href="#CURD操作" class="headerlink" title="CURD操作"></a><strong>CURD操作</strong></h2><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a><strong>外键</strong></h2><p>MyISAM：不支持<br>InnoDB：支持<br>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 存储引擎 </tag>
            
            <tag> MyISAM </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直击HashMap源码</title>
      <link href="/%E7%9B%B4%E5%87%BBHashMap%E6%BA%90%E7%A0%81.html"/>
      <url>/%E7%9B%B4%E5%87%BBHashMap%E6%BA%90%E7%A0%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在开发当中常常会用到HashMap这个对象，去存储key-value的数据，但是大多数时候我们都没去细细分析HashMap的源码。</p><p>今天我就来跟着HashMap源码来分析HashMap是如何实现存储，扩容，以及性能优化的。</p><a id="more"></a><p>为了方便查看可以快速检索文章大纲</p><h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><p>HashMap是通过 数组+单向链表+红黑树 3种数据结构来存储key和value的</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200616204303.jpg" alt="HashMap数据结构"></p><p>这里先提前说一下 hashmap中key的寻址方法是</p><p>数组地址= （ hashcode ^ (hashcode &gt;&gt;&gt; 16) ） &amp; (数组长度 - 1)</p><p>等等会在源码当中详细讲解</p><h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h2><h3 id="1-HashMap包含的字段分析"><a href="#1-HashMap包含的字段分析" class="headerlink" title="1.HashMap包含的字段分析"></a>1.HashMap包含的字段分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化散列表大小  1 &lt;&lt; 4 = 16  二进制的10000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 最大的散列表大小 1 &lt;&lt; 30 挺大一个数字基本不可能达到</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认加载因子 0.75f 扩容的阈值 = 容器当前大小 * 负载因子</span></span><br><span class="line"><span class="comment">* 默认16容器大小 所以 16 * 0.75 = 12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 树化阈值 当链表长度 &gt;= 8 时 进入树化的treeify方法 将链表变为红黑树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红黑树降级为链表的阈值 &lt;= 6时 进入untreeify方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 最小树化的容器大小 散列表数组的长度 &lt; 64时 是不会树化的</span></span><br><span class="line"><span class="comment">* 所以当某个桶位链表的长度 &gt;= 8 且 散列表数组的长度 &lt; 64时 会让其扩容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 散列表对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 散列表中元素的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 操作次数 put remove的时候都会操作该对象 替换的时候不会操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扩容阈值 在初始化散列表的时候会赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 负载因子 在初始化HashMap的时候会赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialCapacity 初始化散列表大小</span></span><br><span class="line">    <span class="comment">// loadFactor 负载因子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//简单的判断 初始化容器的大小肯定不能 &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//这里是判断 传入的容器大小是否大于 之前讲过的最大散列表大小 1 &lt;&lt; 30</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        <span class="comment">//如果大于最大的限制，那么容器的设置就为最大的限制 1 &lt;&lt; 30</span></span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简单的判断 传入的负载因子是否 &lt;= 0 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值负载因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 这里是赋值了扩容阈值</span></span><br><span class="line">    <span class="comment">// 接下来我们看看tableSizeFor方法 阅读tableSizeFor方法后可以知道</span></span><br><span class="line">    <span class="comment">// 当使用有参数构造函数 实例化HashMap时 初始化的扩容阈值等于传入的扩容阈值</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里一系列位运算操作 可以知道 HashMap散列表的大小肯定是 2的次方数</span></span><br><span class="line">    <span class="comment">//比如 传入的cap = 7 经过以下的运算后为8</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 简单的三目运算 比较 最大散列表数组大小</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里是套娃的方法</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化的时候 赋值默认的负载因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-resize方法"><a href="#2-resize方法" class="headerlink" title="2.resize方法"></a>2.resize方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//定义一个变量 赋值还没操作的散列表对象 可以理解为老散列表</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//赋值老的散列表长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//老的扩容阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 定义一个新的散列表大小 新的扩容阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//老的散列表</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 判断是否大于最大散列表大小</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               <span class="comment">//一系列简单操作</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="comment">//如果大于最大散列表大小  不管怎么扩容都没用了</span></span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// oldCap &lt;&lt; 1 可以粗略理解为 oldCap * 2 并且赋值给newCap</span></span><br><span class="line">           <span class="comment">// 1. 判断老的散列表大小*2 是否 &lt; 大的散列表大小</span></span><br><span class="line">           <span class="comment">// 2. 判断老的散列表大小 是否 = 表大小 1 &lt;&lt; 4 = 16</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">//以上两种情况满足 新的扩容阈值 = 老的扩容阈值 * 2</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">           <span class="comment">//以上可以看出 HashMap扩容策略 是 当前的数组长度 &lt;&lt; 1</span></span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 老的扩容阈值 &gt; 0 这种情况什么时候会存在 </span></span><br><span class="line">    <span class="comment">// 当调用有参构造器初始化hashmap的时候散列表数组大小可以手动设置为0</span></span><br><span class="line">    <span class="comment">// 此时的扩容阈值 = 1 这种情况会进入此方法</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 这里是指hashmap的散列表还没有被初始化的时候 执行的方法</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           <span class="comment">// 扩容阈值 = 默认负载因子 * 默认散列表大小 = 0.75f * 16 = 12</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当进入 else if (oldThr &gt; 0) 时会执行以下代码</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里就是新建一个散列表 然后赋值的方法了 细节可以慢慢去研究 省略</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">// 三种情况 桶位没有Node对象 直接就赋值了</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">// 判断 是否树化 </span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">// 链表的情况</span></span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-put方法"><a href="#3-put方法" class="headerlink" title="3. put方法"></a>3. put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到put方法是个套娃的方法，套了<code>putVal</code>方法并且方法的参数中调用了<code>hash(key)</code>的方法</p><p>我们先分析<code>hash(key)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//这里是一个扰乱的方法 将key原本的hashCode异或上 h &gt;&gt;&gt; 16 位</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到实际上HashMap不是直接拿<code>key.hashCode()</code>来做剩下的操作的</p><p>接下来我们看<code>putVal</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab 散列表对象</span></span><br><span class="line">    <span class="comment">//p 寻址后散列表某个索引桶位上的节点对象</span></span><br><span class="line">    <span class="comment">//n 散列表数组的长度</span></span><br><span class="line">    <span class="comment">//i 寻址算法找到的散列表索引</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果HashMap中的table没有初始化 执行resize()初始化 并且将初始化后的散列表数组长度赋值给n</span></span><br><span class="line">    <span class="comment">// 这里可以看出 HashMap中的散列表不是在实例化HashMap时初始化的 而是懒加载</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 这里有两种情况</span></span><br><span class="line">    <span class="comment">// 1.寻址后桶位上的节点正好没有值</span></span><br><span class="line">   <span class="comment">// 2.寻址后桶位上的节点有值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻址算法 之前hash（key）方法扰乱后的hash值 &amp; 当前散列表长度 - 1 = 散列表中应当存放的索引</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//简单的初始化Node对象 赋值给tab[i]</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻址后桶位上节点有值的情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// e 节点</span></span><br><span class="line">            <span class="comment">// k 存入hashMap的key</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里可以看到 hashMap比较对象的时候 有3步</span></span><br><span class="line">            <span class="comment">//1.比较扰乱后的hash值 这里需要注意 不是key原本的hashCode而是之前hash(key)方法扰乱后的hash</span></span><br><span class="line">            <span class="comment">//2. 比较key在内存中的地址</span></span><br><span class="line">            <span class="comment">//3. 调用key对象的equals方法对比</span></span><br><span class="line">            <span class="comment">//所以当HashMap中要存入自定义对象的时候 要重写hashCode方法和equals方法</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果节点已经树化了 走红黑树的方法 这里就不细讲红黑树相关的了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是链表的情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 循环寻找空位插入</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//找到空位 插入Node</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 这里就是判断是否达到树化阈值</span></span><br><span class="line">                        <span class="comment">// TREEIFY_THRESHOLD - 1 比较 是因为 binCount从0开始的</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">//节点树化的方法</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里是判断当找到 key相同的Node节点时 是否替换值</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// onlyIfAbsent == false 或者 null时 会替换原来的值为新值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//操作数 自增</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    <span class="comment">//散列表元素数量 自增  并且判断是否大于扩容阈值</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">//扩容</span></span><br><span class="line">            resize();</span><br><span class="line">    <span class="comment">//此处是LinkedHashMap调用的方法 HashMap此方法内没有执行任何操作</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>该片文章只是起到抛转引玉的作用 HashMap最核心的方法实际上就是putVal和remove方法，当明白了putVal方式，我想聪明的你们肯定自己看remove方法或者其他方法没有问题。</p><p>自律使人成长，自律使人成功~ 大家一起加油！</p>]]></content>
      
      
      <categories>
          
          <category> Java直击源码系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM与JAVA体系</title>
      <link href="/JVM%E4%B8%8EJAVA%E4%BD%93%E7%B3%BB.html"/>
      <url>/JVM%E4%B8%8EJAVA%E4%BD%93%E7%B3%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a><font color=red>重点</font></h1><p>只要符合JVM规范的字节码<br>都能在JVM上运行 不管是什么高级语言编写的</p><h1 id="JVM特点"><a href="#JVM特点" class="headerlink" title="JVM特点"></a><font color=red>JVM特点</font></h1><ol><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收 </li></ol><h1 id="回收机制历史"><a href="#回收机制历史" class="headerlink" title="回收机制历史"></a><font color=red>回收机制历史</font></h1><ol><li>jdk7出现G1回收</li><li>jdk9将G1默认替代CMS</li><li>jdk11出现ZGC性能特别高<br>4 . 2019年 redhat公司发布 shenandoah GC<a id="more"></a><h1 id="指令集结构"><a href="#指令集结构" class="headerlink" title="指令集结构"></a>指令集结构</h1>Java编译器输入的指令流基本上一种基于<font color=red>栈的指令集架构</font>，另外一种指令集架构责是基于<font color=red>寄存器的指令集架构</font>。</li></ol><p>具体来说：这两种架构之间的区别：</p><ol><li>基于栈式架构的特点</li></ol><ul><li>设计和实现更简单，适用于资源受限的系统。</li><li>避开了寄存器的分配难题：使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><ol start="2"><li>基于寄存器架构的特点</li></ol><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分的情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主 </li></ul><h1 id="虚拟机有哪些-三大商用JVM-HotSpot-JRokit-J9"><a href="#虚拟机有哪些-三大商用JVM-HotSpot-JRokit-J9" class="headerlink" title="虚拟机有哪些 三大商用JVM HotSpot JRokit J9"></a>虚拟机有哪些 三大商用JVM HotSpot JRokit J9</h1><ol><li>Sun Classic VM 这款虚拟机内只提供了解释器 HotSpotVM内置了Sun Classic VM </li><li>Exact VM 准确的内存管理 虚拟机可以知道内存中某个位置的数据具体是什么类型 具有现代高性能虚拟机的雏形（热点探测，编译器与解释器混合工作模式）</li><li>HotSpot VM Sun/Oracle JDK的默认虚拟机(其他两个虚拟机都没有“方法区的概念”)</li><li>BEA的JRockit 专注于服务器端应用 不包含解释器，全部用都用编译器编译后执行 JRockit是世界上最快的JVM 全面的Java运行时解决方案 Oracle收购BEA后想整合HotSpot和JRokit的优秀特性</li><li>IBM的J9 与HotSpot接近 服务器端，桌面应用，嵌入式等多用途JVM </li><li>KVM和CDC/CLDC HotSpot Oracle在JavaME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM  KVM(Kilobyte<br>)是CLDC-HI的早期产品</li><li>Azul VM前面三大“高性能Java虚拟机”使用在通用硬件平台上。 这里AzulVM和BEA LiquidVM是和特定硬件平台绑定、软硬件配合的专有虚拟机 高性能虚拟机中战斗机</li><li>Liquid VM 是BEA公司开发的直接运行在自家的系统上</li><li>Apache Harmony</li><li>Microsoft JVM</li><li>TaobaoJVM 是阿里巴巴基于OpenJDK HotSpotVM发布的国内第一优化、深度定制且开元的高性能服务器版java虚拟机 技术实现了off-heap <font color=red>将生命周期较长的java对象从heap中移动到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的，并且GCIH中的对象还能够在多个Java虚拟机进程中实现共享</font></li><li>DalvikVM只能乘坐虚拟机，不能叫做Java虚拟机没有遵循Java虚拟机规范，基于寄存器架构不是JVM的栈架构 之后Android替换为ART VM</li></ol><h1 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h1><p>2018年4月 Oracle Labs公开了Graal VM Graal虚拟机在HotSpot VM基础上增强而成的<font color=red>跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用</font> 包括Java、Scala、Groovy、Kotlin；C、C++、JavaScript、Rubby、Python、R等 </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F.html"/>
      <url>/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ol><li>jclasslib bytecode viewer</li><li>binary viewer</br></li></ol><p>以上idea均有插件</p><h1 id="step1-加载"><a href="#step1-加载" class="headerlink" title="step1 加载"></a>step1 加载</h1><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流锁代表的静态存储结构转化为方法区的运行时数据结构</li><li><font color=red>在内存中生成一个代表这个类的java.lang.Class对象</font>,作为方法区这个类的各种数据的访问入口</li></ol><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><ul><li>JVM支持两种类型的类加载器，分别为<font color=red>引导类加载器（Bootstrap ClassLoader）</font>和<font color=red>自定义类加载器（User-Defined ClassLoader）</font></li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范没有这么定义，而是<font color=red>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</font></li><li>无论类加载器的类型如何划分，在程序中我们最常见的引导类类加载器始终只有3个<a id="more"></a><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3></li><li>启动类加载器（引导类加载器， Bootstrap ClassLoader）<ol><li>这个类加载<font color=red>使用C/C++语言实现的</font>，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol></li><li>扩展类加载器（Extension ClassLoader）<ol><li><font color=red>Java语言编写</font>，由sun.misc.Launcher$ExtClassLoader实现。</li><li><font color=red>派生于ClassLoader类</font></li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）加载类库。<font color=red>如果用户创建的jar放在此目录下，也会自动扩展类加载器加载</font></li></ol></li><li>应用程序类加载器（系统类加载器，AppClassLoader）<ol><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader#getSystemClassLoader()方法可以获取到该加载器</li></ol></li><li>用户自定义类加载器<ol><li>在java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方法</li><li>为什么要自定义类加载器<ul><li>隔离加载类</li><li>修改类加载方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul></li></ol></li></ul><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都能继承自ClassLoader（不包括启动类加载器）</p><h3 id="补充：加载-class文件的方式"><a href="#补充：加载-class文件的方式" class="headerlink" title="补充：加载.class文件的方式"></a>补充：加载.class文件的方式</h3><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：web applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多：<font color=red>动态代理技术</font></li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h1 id="step2-链接"><a href="#step2-链接" class="headerlink" title="step2 链接"></a>step2 链接</h1><ol><li>验证（Verify） <ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的准确性不会危害虚拟机自身安全 JVM要求.class文件的字节流开头都是CA FE BA BE开头 </li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证 </li></ul></li><li>准备（Prepare）<ul><li>为类变量分配内存并且设置该类变量的默认初始值，例如int类型 = 0</li><li><font color=red>这里不包含final修饰的static,因为final在编译的时候就会分配了。准备阶段会显式初始化</font></li><li><font color=red>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</font></li></ul></li><li>解析（Resolve）<ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Ckass文件格式中，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。<h1 id="step3-初始化"><a href="#step3-初始化" class="headerlink" title="step3 初始化"></a>step3 初始化</h1></li></ul></li></ol><ul><li>初始化阶段就是执行类构造器方法<clinit>()的过程</li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量（静态变量）的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）</li><li>若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕。</li><li>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。</li></ul><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先加载，而是把这个请求委托给父类加载器去执行;</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器;</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2></li></ol><ul><li>避免类的重复加载</li><li>保护程序自身安全<ol><li>自定义类： java.lang.String</li><li>自定义类使用引导类加载器内管辖范围的包路径 比如java.lang.Test<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java/lang/String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制</li></ol></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="判断两个class对象是否为同一个类"><a href="#判断两个class对象是否为同一个类" class="headerlink" title="判断两个class对象是否为同一个类"></a>判断两个class对象是否为同一个类</h2><ol><li>在JVM中表示两个class对象是否为同一个类存在两个必要条件：<ul><li>类的完整名称一致，并且包名一致</li><li>加载这个类的ClassLoader（类加载器）必须相同。</li></ul></li><li>换句话说，在JVM中，即使这两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol><h2 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h2><p>JVM必须知道一个类型是由启动加载器加载的，还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<font color=red>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</font>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN防盗链与有效使用CDN缓存</title>
      <link href="/CDN%E9%98%B2%E7%9B%97%E9%93%BE%E4%B8%8E%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8CDN%E7%BC%93%E5%AD%98.html"/>
      <url>/CDN%E9%98%B2%E7%9B%97%E9%93%BE%E4%B8%8E%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8CDN%E7%BC%93%E5%AD%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="CDN防盗链"><a href="#CDN防盗链" class="headerlink" title="CDN防盗链"></a>CDN防盗链</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在我们搭建自己的阿里云CDN时，加快我们站点的静态文件响应速度。</p><p>但是与此同时，我们站点里的某些静态资源可能会被其他用户所盗取，然后使用我们的流量让他们的站点变得更流畅。</p><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>假设我们的网站为A 里面有一个静态的CDN链接</p><p>此时用户B看到我们的网站里的CDN链接并盗用了我这个链接，发布在他们自己的网站上。</p><p>此时用户看到用户B的图片的流程图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">用户 --&gt; 站点B --&gt; CDN链接图片</span><br></pre></td></tr></table></figure><p>可以看见用户并不知道这个CDN链接是属于我的，此时站点B就是在盗用我的CDN链接，并且没有给我带来流量。使用 阿里云CDN是存在外网下行流量费用和请求费用的。</p><p>站点B这样的行为我称之为”白嫖“。</p><p>如果我们只是站在在道德层面上去指责别人，并不采取措施，我们的钱包里的钱就是为他人来带便利和流量。</p><p>所以我们需要<font color="red">CDN防盗链</font></p><a id="more"></a><h2 id="阿里云配置"><a href="#阿里云配置" class="headerlink" title="阿里云配置"></a>阿里云配置</h2><h2 id="step1：找到CDN防盗链配置"><a href="#step1：找到CDN防盗链配置" class="headerlink" title="step1：找到CDN防盗链配置"></a>step1：找到CDN防盗链配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">CDN控制台 --&gt; 域名管理 --&gt; 管理 --&gt; 访问控制 --&gt; Referer防盗链</span><br></pre></td></tr></table></figure><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424132150.png" alt="找到CDN防盗链配置"></p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424132329.png" alt="找到CDN防盗链配置"></p><h2 id="step2-配置防盗链"><a href="#step2-配置防盗链" class="headerlink" title="step2: 配置防盗链"></a>step2: 配置防盗链</h2><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424132436.png" alt="配置防盗链"></p><p>我配置允许通过浏览器地址栏直接访问资源url，如果关闭了，我们的域名访问我们的站点如果配置了cdn将无法被访问了。</p><p>以下是阿里云帮助文档对防盗链配置的描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置防盗链功能，包括以下参数：</span><br><span class="line"></span><br><span class="line">- Referer 白名单。仅允许指定的域名访问 CDN 资源。</span><br><span class="line">- 是否允许空 Referer。如果不允许空 Referer，则只有 HTTP 或 HTTPS header 中包含 Referer 字段的请求才能访问 CDN 资源。</span><br><span class="line"></span><br><span class="line">例如，对于一个名为 oss-example 的 Bucket，设置其 Referer 白名单为`https://www.aliyun.com/`。则所有 Referer 为`https://www.aliyun.com/`的请求才能访问 oss-example 这个 Bucket 中的 Object。</span><br></pre></td></tr></table></figure><p>到这里就已经配置完成了，你可以尝试在本地的网页上引用该图片路径，发现无法访问，配置成功。</p><p>我们可以放心CDN链接流量不会被其他网站盗用了。</p><h1 id="有效使用CDN缓存"><a href="#有效使用CDN缓存" class="headerlink" title="有效使用CDN缓存"></a>有效使用CDN缓存</h1><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>当我们配置好自己的CDN加速站点后，发现我们加载页面的时候会比较慢。</p><p>这是为什么呢？明明配置了CDN加速，并且理论上配置后速度应该很快才对，凭什么我的就比较慢呢？</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>稍加思索，我用chrome浏览器打开F12看到</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424133614.png" alt=""></p><p>为啥我这么多静态文件加载速度这么慢？ 特别是有好几个js文件只有几十kb，为啥加载将近1秒或者1秒以上？</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>根据我的非专业理解分析（PS：图画得有点丑见谅=。=）</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424134609.jpg" alt=""></p><p>根据图可知：</p><p>原来在CDN服务器上会去判断该静态文件是否被缓存了，现在我开通阿里云CDN后还没有去配置过任何CDN缓存相关的东西（PS：我最开始以为阿里云会自动为我缓存=。=）。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="找到配置地点"><a href="#找到配置地点" class="headerlink" title="找到配置地点"></a>找到配置地点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">域名管理 --&gt; 找到需要配置的域名 --&gt; 管理 --&gt; 缓存配置 --&gt; 缓存过期时间 --&gt; 添加</span><br></pre></td></tr></table></figure><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424135043.png" alt=""></p><h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424135440.png" alt=""></p><p>这里我是配置的目录 代表在我域名下所有的目录都将被缓存在CDN里</p><p>当然这里可以根据需要配 文件名后缀 或者目录。</p><p>至于过期时间可以根据自己的使用去设置。</p><h3 id="使用后效果"><a href="#使用后效果" class="headerlink" title="使用后效果"></a>使用后效果</h3><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424135847.png" alt=""></p><p>可以看到相同的js已经加入CDN缓存后加载时间已经降低到几十ms了，速度已经大大的加快了。</p><p>这里需要注意的是：<font color="red">配置好CDN缓存后第一次加载可能还是会比较慢，因为CDN服务器中还没有该文件的缓存，还是要去服务器拉取，此时的速度也是根据服务器带宽来区分的。第二次加载时CDN中已经有缓存了，速度会非常快~</font></p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>在我们配置过程中，我们可以看到性能优化几个字眼（PS：我对性能两个字比较敏感，虽然还有安全配置啥的，但是我个人博客服务器我对安全就不太关注了，毕竟还要付费，哈哈哈）</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424140443.png" alt=""></p><p>把能点的都点上把，毕竟压缩文件也能节约流量，降低CDN使用成本。</p>]]></content>
      
      
      <categories>
          
          <category> 阿里云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云 </tag>
            
            <tag> CDN </tag>
            
            <tag> 防盗链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSS防盗链</title>
      <link href="/OSS%E9%98%B2%E7%9B%97%E9%93%BE.html"/>
      <url>/OSS%E9%98%B2%E7%9B%97%E9%93%BE.html</url>
      
        <content type="html"><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在我们搭建自己的阿里云OSS时，里面存储了许多我们运用的静态文件（图片、js、css）等。</p><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>假设我们的网站为A 里面有了OSS的链接</p><p>此时用户B看到我们的网站里的OSS链接并盗用了我这个链接，发布在他们自己的网站上。</p><p>此时用户看到用户B的图片的流程图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">用户 --&gt; 站点B --&gt; OSS链接</span><br></pre></td></tr></table></figure><p>可以看见用户并不知道这个OSS链接是属于我的，此时站点B就是在盗用我的OSS链接，并且没有给我带来流量。使用 阿里云OSS是存在外网下行流量费用和请求费用的。</p><p>站点B这样的行为我称之为”白嫖“。</p><p>如果我们只是站在在道德层面上去指责别人，并不采取措施，我们的钱包里的钱就是为他人来带便利和流量。</p><p>所以我们需要<font color="red">OSS防盗链</font></p><a id="more"></a><h1 id="阿里云配置"><a href="#阿里云配置" class="headerlink" title="阿里云配置"></a>阿里云配置</h1><h2 id="step1：找到OSS防盗链配置"><a href="#step1：找到OSS防盗链配置" class="headerlink" title="step1：找到OSS防盗链配置"></a>step1：找到OSS防盗链配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">OSS控制台 --&gt; Bucket列表 --&gt; 权限管理 --&gt; 防盗链</span><br></pre></td></tr></table></figure><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424125841.png" alt="找到OSS防盗链配置"></p><h2 id="step2-配置防盗链"><a href="#step2-配置防盗链" class="headerlink" title="step2: 配置防盗链"></a>step2: 配置防盗链</h2><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424130806.png" alt="配置防盗链"></p><p>以下是阿里云帮助文档对防盗链配置的描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置防盗链功能，包括以下参数：</span><br><span class="line"></span><br><span class="line">- Referer 白名单。仅允许指定的域名访问 OSS 资源。</span><br><span class="line">- 是否允许空 Referer。如果不允许空 Referer，则只有 HTTP 或 HTTPS header 中包含 Referer 字段的请求才能访问 OSS 资源。</span><br><span class="line"></span><br><span class="line">例如，对于一个名为 oss-example 的 Bucket，设置其 Referer 白名单为`https://www.aliyun.com/`。则所有 Referer 为`https://www.aliyun.com/`的请求才能访问 oss-example 这个 Bucket 中的 Object。</span><br></pre></td></tr></table></figure><p>到这里就已经配置完成了，你可以尝试在本地的网页上引用该图片路径，发现无法访问，配置成功。</p><p>我们可以放心OSS链接流量不会被其他网站盗用了。</p>]]></content>
      
      
      <categories>
          
          <category> 阿里云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云 </tag>
            
            <tag> 防盗链 </tag>
            
            <tag> OSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用浏览器缓存减少CDN请求</title>
      <link href="/%E8%BF%90%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%87%8F%E5%B0%91CDN%E8%AF%B7%E6%B1%82.html"/>
      <url>/%E8%BF%90%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%87%8F%E5%B0%91CDN%E8%AF%B7%E6%B1%82.html</url>
      
        <content type="html"><![CDATA[<h1 id="CDN将静态文件存储在浏览器"><a href="#CDN将静态文件存储在浏览器" class="headerlink" title="CDN将静态文件存储在浏览器"></a>CDN将静态文件存储在浏览器</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>当我们配置好自己的CDN缓存后，我们还会发现每次都会发起请求CDN，这样对于“勤俭节约”的我来说是十分浪费，且用户也会感觉页面加载速度会稍微有丢丢慢。</p><p>该如何去解决呢？</p><a id="more"></a><h2 id="使用浏览器缓存"><a href="#使用浏览器缓存" class="headerlink" title="使用浏览器缓存"></a>使用浏览器缓存</h2><p>这里相信许多大佬应该知道http header中的cache-control和expires</p><hr><h3 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h3><p>这东西简单的说就是告诉浏览器，这个静态文件是需要缓存的，缓存的时间我会告诉你</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: public, max-age=86400</span><br></pre></td></tr></table></figure><p>以上这个配置呢，就是说浏览器能保存这个文件缓存时间为86400秒，就是1天。</p><p>具体的参数</p><p><code>Public</code> 指示响应可被任何缓存区缓存。<br><code>Private</code> 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的<br>部分响应消息，此响应消息对于其他用户的请求无效。<br><code>no-cache</code> 指示请求或响应消息不能缓存（HTTP/1.0用Pragma的no-cache替换）<br>根据什么能被缓存<br><code>no-store</code> 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>根据缓存超时<br><code>max-age</code> 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。<br><code>min-fresh</code> 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。<br><code>max-stale</code> 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。我也不太懂这什么意思。一般也没用。</p><h4 id="使用的弊端"><a href="#使用的弊端" class="headerlink" title="使用的弊端"></a>使用的弊端</h4><p>这么使用也是有弊端的，你不能把用户当成什么都会的人，你就把用户当成傻白甜，然后她请求获取到静态文件缓存后，此时我更新了这些静态文件可咋办，用户端的静态文件缓存也不会即时更新，这种一般就是在静态文件后面加个版本号，这种解决方式也挺多的，啥在js文件名后加个日期啥的。大家可以自己研究研究，我有时间也会在这上面去捣鼓一下=。=</p><hr><h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h3><p>静态文件缓存的失效时间</p><p>数据包中的格式：<br><code>Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date</code><br>例如<br><code>Expires: Thu, 01 Dec 1994 16:00:00 GMT</code> （必须是GMT格式）</p><hr><h3 id="阿里云CDN配置HTTP头"><a href="#阿里云CDN配置HTTP头" class="headerlink" title="阿里云CDN配置HTTP头"></a>阿里云CDN配置HTTP头</h3><p>当我们使用CDN时，我们的域名通过CNAME转发到CDN服务器上，CDN服务器再请求我们的资源，我这里不管怎么在我的nginx服务器上配expires和cache-control都没法加到最后页面上的请求头中（大佬们要是加出来了，别打我，我也是大半夜捣鼓这玩意儿有点懵逼了，我还没去排查是不是CDN缓存的原因造成的。）</p><p>这里阿里云的CDN，Tengine服务器就提供了HTTP头的配置</p><p>域名管理 –&gt; 要配置的域名 –&gt; 管理 –&gt; 缓存配置 –&gt; HTTP头 –&gt; 点击添加</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/image-20200424223217262.png" alt="image-20200424223217262"></p><p>这里阿里云提供了10种HTTP头</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Content-Type</td><td align="left">指定客户端程序响应对象的内容类型。</td><td align="left">image</td></tr><tr><td align="left">Cache-Control</td><td align="left">指定客户端程序请求和响应遵循的缓存机制。</td><td align="left">no-cache</td></tr><tr><td align="left">Content-Disposition</td><td align="left">指定客户端程序把请求所得的内容存为一个文件时提供的默认的文件名。</td><td align="left">123.txt</td></tr><tr><td align="left">Content-Language</td><td align="left">指定客户端程序响应对象的语言。</td><td align="left">zh-CN</td></tr><tr><td align="left">Expires</td><td align="left">指定客户端程序响应对象的过期时间。</td><td align="left">Wed, 21 Oct 2015 07:28:00 GMT</td></tr><tr><td align="left">Access-Control-Allow-Origin</td><td align="left">指定允许的跨域请求的来源。</td><td align="left"><strong>*说明</strong> 您可以填写<code>*</code>表示全部域名；也可以填写完整域名，例如<code>www.aliyun.com</code>。</td></tr><tr><td align="left">Access-Control-Allow-Headers</td><td align="left">指定允许的跨域请求的字段。</td><td align="left">X-Custom-Header</td></tr><tr><td align="left">Access-Control-Allow-Methods</td><td align="left">指定允许的跨域请求方法。</td><td align="left">POST、GET</td></tr><tr><td align="left">Access-Control-Max-Age</td><td align="left">指定客户端程序对特定资源的预取请求返回结果的缓存时间。</td><td align="left">600</td></tr><tr><td align="left">Access-Control-Expose-Headers</td><td align="left">指定允许访问的自定义头信息。</td><td align="left">Content-Length</td></tr></tbody></table><p><font color="red">注意！！！如果配置了CDN缓存，此时你迫不及待的去刷新页面，如果没看到你配置的响应头，需要你去刷新下CDN缓存目录</font></p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/image-20200424223620036.png" alt="image-20200424223620036"></p><p><font color="red">这里填入你完整的域名提交刷新下</font></p><p>此处要注意是因为，我第一次刷新的时候没有出现，但是我没反复校验是不是因为HTTP头配置还没生效，我配置完成后很快就跑去刷新了，然后我条件反射就直接去刷新CDN缓存了。</p><p>如果配置成功，一直刷新不出响应头，我大胆的猜测是因为CDN服务器判断到有缓存，没有从我们的服务器拉取资源，直接把缓存中存储好包含HTTP头的资源返回了。</p><hr><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>大半夜学习，有点懵逼，有空的时候我还是要再去深入理解下这块的原理。比如HTTP头，对于我这样的菜鸟Java程序员来说还算是盲区。此处记录也希望能帮助更多的人，不管在工作中，还是在自我鞭策学习中，少走弯路。</p>]]></content>
      
      
      <categories>
          
          <category> 阿里云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的Next主题如何添加动态背景</title>
      <link href="/Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF.html"/>
      <url>/Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF.html</url>
      
        <content type="html"><![CDATA[<h2 id="修改-layout-swig"><a href="#修改-layout-swig" class="headerlink" title="修改_layout.swig"></a>修改_layout.swig</h2><p>打开博客根目录下<code>themes/next/layout/_layout.swig</code></p><p>在<code>&lt;/body&gt;</code>之前添加代码</p><p>（理论上来说js标签放在html文档的任何位置都可以，规范起见，推荐放到body结束标签的末尾，包含到body标签内：这样处理的好处是无需担心因页面未完成加载，造成DOM节点获取不到，使脚本报错的问题，而且能避免因脚本运行缓慢造成页面卡死的问题。另外，Yahoo的前端优化指南里就有这一条。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><p>注意这里引用的CDN文件<font color="red">建议下载到本地然后引用</font>这样的好处是如果某天这个CDN链接404了，我们还能运用</p><a id="more"></a><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p><code>/next/_config.yml</code>,在里面添加如下代码：(可以放在最后面)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否打开动态背景</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>到此就结束了，运行 <code>hexo clean</code>，然后运行 <code>hexo g -d</code>,然后运行 <code>hexo s</code>，最后打开浏览器在浏览器的地址栏输入 <code>localhost:4000</code> 就能看到效果了</p><h3 id="如果你感觉默认的线条不好看的话"><a href="#如果你感觉默认的线条不好看的话" class="headerlink" title="如果你感觉默认的线条不好看的话"></a>如果你感觉默认的线条不好看的话</h3><p>在上一步修改 <code>_layout.swig</code>中，把刚才的这些代码改为，CDN引用js存放路径为next主题下<code>source/js/canvas-nest.min.js</code>，以下是我的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 动态背景--&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">    &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">color</span>=<span class="string">"0,0,0"</span> <span class="attr">opacity</span>=<span class="string">'0.8'</span> <span class="attr">zIndex</span>=<span class="string">"-2"</span> <span class="attr">count</span>=<span class="string">"200"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>--&gt;</span><br><span class="line">    &lt;script color=<span class="string">"0,0,0"</span> opacity=<span class="string">'0.8'</span> zIndex=<span class="string">"-2"</span> count=<span class="string">"200"</span> type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/canvas-nest.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配置项说明"><a href="#配置项说明" class="headerlink" title="配置项说明"></a>配置项说明</h3><ul><li><code>color</code> ：线条颜色, 默认: <code>&#39;0,0,0&#39;</code>；三个数字分别为(R,G,B)</li><li><code>opacity</code>： 线条透明度（0~1）, 默认: <code>0.5</code></li><li><code>count</code>： 线条的总数量, 默认: <code>150</code></li><li><code>zIndex</code>： 背景的z-index属性，css属性用于控制所在层的位置, 默认: <code>-1</code></li></ul><p>以上是站在<a href="https://www.jianshu.com/p/ea3990fe76f6" target="_blank" rel="noopener">搭建博客使用hexo的next主题如何添加动态背景</a>的肩膀上整理的博文，感谢大佬们辛苦研究整理出的博文推进我们在开发的不归路上越走越远。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Next主题 文章添加阅读次数，访问量等</title>
      <link href="/Hexo+Next%E4%B8%BB%E9%A2%98%20%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%EF%BC%8C%E8%AE%BF%E9%97%AE%E9%87%8F%E7%AD%89.html"/>
      <url>/Hexo+Next%E4%B8%BB%E9%A2%98%20%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%EF%BC%8C%E8%AE%BF%E9%97%AE%E9%87%8F%E7%AD%89.html</url>
      
        <content type="html"><![CDATA[<h1 id="修改博客配置文件，添加以下代码"><a href="#修改博客配置文件，添加以下代码" class="headerlink" title="修改博客配置文件，添加以下代码"></a>修改博客配置文件，添加以下代码</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码"><a href="#修改主题配置文件，搜索symbols-count-time，快速定位，修改成以下代码" class="headerlink" title="修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码"></a>修改主题配置文件，搜索symbols_count_time，快速定位，修改成以下代码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装hexo</title>
      <link href="/%E5%AE%89%E8%A3%85hexo.html"/>
      <url>/%E5%AE%89%E8%A3%85hexo.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p><a href="[https://www.wukong918.cn/%E5%AE%89%E8%A3%85node.html](https://www.wukong918.cn/%E5%AE%89%E8%A3%85node.html)">Node.js安装直通车</a></p><hr><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo必需的依赖包hexo-cli 如果MacOS安装提示没有权限写入请在命令最前面加上sudo并输入密码</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录下初始化项目 <span class="built_in">cd</span> 进入你需要初始化项目的目录</span></span><br><span class="line">cd ~</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化项目到当前目录</span></span><br><span class="line">hexo init my_blog</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="初始化后我是这样"><a href="#初始化后我是这样" class="headerlink" title="初始化后我是这样"></a>初始化后我是这样</h2><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200422133616.png" alt="image-20200421213547325"></p><h2 id="目录结构详解"><a href="#目录结构详解" class="headerlink" title="目录结构详解"></a>目录结构详解</h2><table><thead><tr><th>名称</th><th align="left">描述</th></tr></thead><tbody><tr><td>node_modules</td><td align="left">这是blog项目存放npm依赖包的地方</td></tr><tr><td>public</td><td align="left">生成的静态文件的存放目录</td></tr><tr><td>scaffolds</td><td align="left">系统声明了几个默认的标签tag,page等等</td></tr><tr><td>source</td><td align="left">这是存放blog项目源文件的地方，也就是存放markdown文章的地方</td></tr><tr><td>themes</td><td align="left">这是存放blog项目主题的地方</td></tr><tr><td>_config.yml</td><td align="left">这是blog项目的全站配置文件</td></tr><tr><td>package</td><td align="left">这是blog项目的hexo依赖版本信息</td></tr><tr><td>package-lock</td><td align="left">这是blog项目的npm依赖包详细版本信息</td></tr></tbody></table><p>这里需要做一些额外说明的是：</p><p>源文件目录source，就是以后我们把写好的Markdown格式文章的存放目录。<br>主题目录themes，hexo允许我们选取自定义的主题。hexo官网主题列表提供了很多可用的主题，我们可以选取自己喜欢的主题，将该主题的源码通过git clone命令下载到该themes目录后，在全站配置文件_config.yml中配置theme属性的值即可启用该主题。<br>全站配置文件_config.yml，hexo允许我们在该配置文件中配置属性值来修改页面的样式。之所以叫“全站配置文件”，除了这个配置文件基本都是进行全局配置之外，还有一个原因是：还有一个“主题配置文件”与之对应。如hexo默认的主题配置文件就是（./themes/landscape/_config.yml）。基于landscape主题，对该配置文件属性值的修改，可以对局部的样式进行修改。</p><hr><h2 id="运行hexo"><a href="#运行hexo" class="headerlink" title="运行hexo"></a>运行hexo</h2><p>执行hexo server命令，在浏览器地址栏输入localhost:4000即可看到如下效果。 </p><p><font color="red">注意：一定要在项目的根目录下./my_blog/ 执行hexo server命令</font></p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200422133621.png" alt="image-20200421214151807"></p><hr><h2 id="hexo命令详解"><a href="#hexo命令详解" class="headerlink" title="hexo命令详解"></a>hexo命令详解</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.hexo init 命令用于初始化本地文件夹为网站的根目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> folder 可选参数，用以指定初始化目录的路径，若无指定则默认为当前目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init [folder]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. hexo new 命令用于新建文章，一般可以简写为 hexo n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> layout 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> title 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo new [layout] &lt;title&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. hexo generate 命令用于生成静态文件，一般可以简写为 hexo g</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 选项，指定生成后部署，与 hexo d -g 等价</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. hexo server 命令用于启动本地服务器，一般可以简写为 hexo s</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 选项，指定服务器端口，默认为 4000</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i 选项，指定服务器 IP 地址，默认为 0.0.0.0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. hexo deploy 命令用于部署网站，一般可以简写为 hexo d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g 选项，指定生成后部署，与 hexo g -d 等价</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. hexo clean 命令用于清理缓存文件，是一个比较常用的命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. hexo --safe 表示安全模式，用于禁用加载插件和脚本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo --safe</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. hexo --debug 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo --debug</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. hexo --silent 表示静默模式，用于静默输出到终端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo --silent</span></span><br></pre></td></tr></table></figure><h2 id="hexo切换Next主题相关优化"><a href="#hexo切换Next主题相关优化" class="headerlink" title="hexo切换Next主题相关优化"></a>hexo切换Next主题相关优化</h2><p>这里引用别的大佬文章，里面各个方面讲述比较详细，有的出现小问题，看看源码也就解决了<a href="https://www.jianshu.com/p/3ff20be8574c" target="_blank" rel="noopener">Hexo-Next-主题优化</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装node</title>
      <link href="/%E5%AE%89%E8%A3%85node.html"/>
      <url>/%E5%AE%89%E8%A3%85node.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h1><hr><h2 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h2><p>访问<strong><a href="http://nodejs.cn/" target="_blank" rel="noopener">Node官网</a></strong>此处我选择的是MacOS安装包</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200422152551.png" alt="QQ截图20200422152340"></p><p>下载完成后点击安装跟着流程走，然后进入控制台 terminal，显示版本号代表成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chenjunfengLocal:~ edison$ node -v</span><br><span class="line">v12.16.2</span><br></pre></td></tr></table></figure><hr><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200422133449.png" alt="image-20200422085725184"></p><p>下载完成后点击安装跟着流程走，然后进入控制台 win+R输入cmd, npm -v，显示版本号代表成功</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;npm <span class="literal">-v</span></span><br><span class="line"><span class="number">6.14</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure><hr><h2 id="npm切换镜像源"><a href="#npm切换镜像源" class="headerlink" title="npm切换镜像源"></a>npm切换镜像源</h2><h3 id="国内优秀的镜像源"><a href="#国内优秀的镜像源" class="headerlink" title="国内优秀的镜像源"></a>国内优秀的镜像源</h3><ol><li>淘宝镜像<ul><li>搜索地址：<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a></li><li>registry地址：<a href="http://registry.npm.taobao.org/" target="_blank" rel="noopener">http://registry.npm.taobao.org/</a></li></ul></li><li>cnpmjs镜像<ul><li>搜索地址：<a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org/</a></li><li>registry地址：<a href="http://r.cnpmjs.org/" target="_blank" rel="noopener">http://r.cnpmjs.org/</a></li></ul></li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>临时使用</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure></li><li><p>永久使用</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置后可通过下面方式来验证是否成功 </span></span><br><span class="line">npm config get registry </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或 </span></span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure></li><li><p>通过cnpm使用 </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行 如果MacOS提示没有权限请在命令前面加上sudo</span></span><br><span class="line">cnpm install express</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>nrm切换源</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 如果MacOS提示没有权限请在命令前面加上sudo</span></span><br><span class="line">npm install -g nrm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出源</span></span><br><span class="line">nrm ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 带 * 的是当前使用的源</span></span><br><span class="line">  npm -------- https://registry.npmjs.org/</span><br><span class="line">  yarn ------- https://registry.yarnpkg.com/</span><br><span class="line">  cnpm ------- http://r.cnpmjs.org/</span><br><span class="line">* taobao ----- https://registry.npm.taobao.org/</span><br><span class="line">  nj --------- https://registry.nodejitsu.com/</span><br><span class="line">  npmMirror -- https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm ----- http://registry.enpmjs.org/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用淘宝的镜像源</span></span><br><span class="line">nrm use taobao</span><br><span class="line">                        </span><br><span class="line">   Registry has been set to: https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试使用速度"><a href="#测试使用速度" class="headerlink" title="测试使用速度"></a>测试使用速度</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm test npm</span><br><span class="line">npm ---- 6279ms #我网络有点差 -。-</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">测试所有源</span></span><br><span class="line">nrm test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/%E6%B3%A8%E8%A7%A3.html"/>
      <url>/%E6%B3%A8%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><p>==内包含大量源码解读==</p><h2 id="1-什么是注解？"><a href="#1-什么是注解？" class="headerlink" title="1.什么是注解？"></a>1.什么是注解？</h2><p>Annotation（注解）是Java提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的Annotation对象，然后通过该Annotation对象来获取注解中的元数据信息。</p><a id="more"></a><h2 id="2-四种标准元注解"><a href="#2-四种标准元注解" class="headerlink" title="2.四种标准元注解"></a>2.四种标准元注解</h2><p>元注解的作用是负责注解其他注解。 Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p><h3 id="1-Target修饰的对象范围"><a href="#1-Target修饰的对象范围" class="headerlink" title="1.@Target修饰的对象范围"></a>1.@Target修饰的对象范围</h3><p>@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，该注解中放入的ElementType枚举数组的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/**  类、接口(包括注释类型)或enum声明 */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字段声明(包括enum常量) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 正式的参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注释类型声明 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型参数声明</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释来自有道翻译,以下是对@Target的使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)<span class="comment">//数组方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)<span class="comment">//直接使用的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Retention定义-被保留的时间长短"><a href="#2-Retention定义-被保留的时间长短" class="headerlink" title="2. @Retention定义 被保留的时间长短"></a>2. @Retention定义 被保留的时间长短</h3><p>@Retention 定义了该Annotation被保留的时间长短：<br>表示需要在什么级别保存注解信息，用于描述注解的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，该注解中放入的RetentionPolicy 枚举的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在源文件中有效（即源文件保留）</span></span><br><span class="line"><span class="comment">     * 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在class文件中有效（即class保留）</span></span><br><span class="line"><span class="comment">     * 注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RUNTIME:在运行时有效（即运行时保留）</span></span><br><span class="line"><span class="comment">     * 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是对@Retention的使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//在运行时保留 无法如@Target一样用数组方式表明多种保留方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Documented描述-javadoc"><a href="#3-Documented描述-javadoc" class="headerlink" title="3. @Documented描述-javadoc"></a>3. @Documented描述-javadoc</h3><p>@ Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。</p><h3 id="4-Inherited阐述了某个被标注的类型是被继承的"><a href="#4-Inherited阐述了某个被标注的类型是被继承的" class="headerlink" title="4. @Inherited阐述了某个被标注的类型是被继承的"></a>4. @Inherited阐述了某个被标注的类型是被继承的</h3><p>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。所以当子类要继承父类某些注解时，这些注解都必须被@Inherited注解修饰</p><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424093731.png" alt="20191124205503749"></p><h2 id="3-注解处理器"><a href="#3-注解处理器" class="headerlink" title="3.注解处理器"></a>3.注解处理器</h2><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。</p><p>这里要强调下注解能使用的所有基本类型（int,float,boolean,byte,double,char,long,short）</p><ul><li><p>String</p></li><li><p>Class</p></li><li><p>enum（枚举类）</p></li><li><p>Annotation</p></li><li><p>上述类型的数组</p></li></ul><h3 id="step1-定义一个注解"><a href="#step1-定义一个注解" class="headerlink" title="step1:定义一个注解"></a>step1:定义一个注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)<span class="comment">//使用目标-字段</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//保留范围-在运行时都存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FieldAnnotation &#123;</span><br><span class="line">   <span class="comment">/** 值 */</span></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span></span>;<span class="comment">//不写default 代表这个是在使用注解时必须填入值</span></span><br><span class="line">   <span class="comment">/** 备注 */</span></span><br><span class="line">   <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step2-定义一个使用注解的类"><a href="#step2-定义一个使用注解的类" class="headerlink" title="step2:定义一个使用注解的类"></a>step2:定义一个使用注解的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用注解的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FieldAnnotation</span>(value = <span class="string">"奥迪A6"</span>)</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="meta">@FieldAnnotation</span>(value = <span class="string">"黑色"</span>)</span><br><span class="line">    <span class="keyword">private</span> String carColor;</span><br><span class="line">    <span class="meta">@FieldAnnotation</span>(value = <span class="string">"240"</span>, desc = <span class="string">"单位：千米每小时"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer maxSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3：定义一个注解处理器"><a href="#step3：定义一个注解处理器" class="headerlink" title="step3：定义一个注解处理器"></a>step3：定义一个注解处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段注解 解析器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAnnotationResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolverObject</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Class clazz = o.getClass();</span><br><span class="line">        <span class="comment">//获取对象所有的字段</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        FieldAnnotation fieldAnnotation = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(FieldAnnotation<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                fieldAnnotation = field.getAnnotation(FieldAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                System.out.println(<span class="string">"字段名:"</span> + field.getName() + <span class="string">"=&gt;"</span> + fieldAnnotation.value() + <span class="string">"/"</span> + fieldAnnotation.desc());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        FieldAnnotationResolver.resolverObject(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果:"></a>输出结果:</h3><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424094325.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常分类及处理</title>
      <link href="/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB%E5%8F%8A%E5%A4%84%E7%90%86.html"/>
      <url>/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB%E5%8F%8A%E5%A4%84%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p><a id="more"></a><p>图为网上借鉴：<br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424094220.png" alt=""></p><h1 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h1><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ol><li><p>Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p></li><li><p>Exception 类是指代码里有可以检查到的异常或者在运行时才会有的异常</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>Exception又有两个分支， 一个是运行时异常RuntimeException ， 一个是<br>CheckedException。</p><h4 id="RuntimeException："><a href="#RuntimeException：" class="headerlink" title="RuntimeException："></a>RuntimeException：</h4><p>如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常CheckedException，如 I/O 错误导致的 IOException、 SQLException。 RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误</p></li></ol><h4 id="检查异常-CheckedException："><a href="#检查异常-CheckedException：" class="headerlink" title="检查异常 CheckedException："></a>检查异常 CheckedException：</h4><p> 一般是外部错误，这种异常都发生在编译阶段， Java 编译器会强<br>制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面：</p><ol><li>试图在文件尾部读取数据</li><li>试图打开一个错误格式的 URL</li><li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</li></ol><h1 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h1><p>遇到问题不进行具体处理，而是继续抛给调用者 （ throw,throws）<br>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。<br>try catch 捕获异常针对性处理方式</p><h2 id="Throw-和-throws-的区别"><a href="#Throw-和-throws-的区别" class="headerlink" title="Throw 和 throws 的区别"></a>Throw 和 throws 的区别</h2><h3 id="位置不同："><a href="#位置不同：" class="headerlink" title="位置不同："></a>位置不同：</h3><ol><li>throws 用在函数上，后面跟的是异常类，可以跟多个； 而 throw 用在函数内，后面跟的是异常对象。<h3 id="功能不同："><a href="#功能不同：" class="headerlink" title="功能不同："></a>功能不同：</h3></li><li>throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式； throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常； throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="/%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
      <url>/%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h1><h2 id="保存-持久化-对象及其状态到内存或者磁盘"><a href="#保存-持久化-对象及其状态到内存或者磁盘" class="headerlink" title="保存(持久化)对象及其状态到内存或者磁盘"></a>保存(持久化)对象及其状态到内存或者磁盘</h2><p>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。 但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。<br>Java 对象序列化就能够帮助我们实现该功能。</p><a id="more"></a><h2 id="序列化对象以字节数组保持-静态成员不保存"><a href="#序列化对象以字节数组保持-静态成员不保存" class="headerlink" title="序列化对象以字节数组保持-静态成员不保存"></a>序列化对象以字节数组保持-静态成员不保存</h2><p>使用 Java 对象序列化， 在保存对象时，会把其状态保存为一组字节，在未来， 再将这些字节组装成对象。必须注意地是， 对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。</p><h2 id="序列化用户远程对象传输"><a href="#序列化用户远程对象传输" class="headerlink" title="序列化用户远程对象传输"></a>序列化用户远程对象传输</h2><p>除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。 Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。</p><h2 id="Serializable-实现序列化"><a href="#Serializable-实现序列化" class="headerlink" title="Serializable 实现序列化"></a>Serializable 实现序列化</h2><p>在 Java 中， 只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。<br>ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。<br>通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。</p><h2 id="writeObject-和-readObject-自定义序列化策略"><a href="#writeObject-和-readObject-自定义序列化策略" class="headerlink" title="writeObject 和 readObject 自定义序列化策略"></a>writeObject 和 readObject 自定义序列化策略</h2><p>在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。</p><h2 id="序列化-ID"><a href="#序列化-ID" class="headerlink" title="序列化 ID"></a>序列化 ID</h2><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）</p><h2 id="序列化并不保存静态变量"><a href="#序列化并不保存静态变量" class="headerlink" title="序列化并不保存静态变量"></a>序列化并不保存静态变量</h2><h2 id="序列化子父类说明"><a href="#序列化子父类说明" class="headerlink" title="序列化子父类说明"></a>序列化子父类说明</h2><p>要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。</p><h2 id="Transient-关键字阻止该变量被序列化到文件中"><a href="#Transient-关键字阻止该变量被序列化到文件中" class="headerlink" title="Transient 关键字阻止该变量被序列化到文件中"></a>Transient 关键字阻止该变量被序列化到文件中</h2><ol><li>在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列化后， transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</li><li>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/%E5%86%85%E9%83%A8%E7%B1%BB.html"/>
      <url>/%E5%86%85%E9%83%A8%E7%B1%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java内部类"><a href="#Java内部类" class="headerlink" title="Java内部类"></a>Java内部类</h1><p>Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根<br>据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。</p><a id="more"></a><h2 id="1-静态内部类"><a href="#1-静态内部类" class="headerlink" title="1.静态内部类"></a>1.静态内部类</h2><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。</li><li>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</li><li>其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示： Out.Inner inner =<br>new Out.Inner();inner.print();</li><li>Java集合类HashMap内部就有一个静态内部类Entry。 Entry是HashMap存放元素的抽象，<br>HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部<br>类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</li></ol><h2 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2.成员内部类"></a>2.成员内部类</h2><p>定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（ final 修饰的<br>除外）。这是因为成员内部类是非静态的， 类初始化的时候先初始化静态成员，如果允许成员内<br>部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-局部内部类（-定义在方法中的类）"><a href="#3-局部内部类（-定义在方法中的类）" class="headerlink" title="3.局部内部类（ 定义在方法中的类）"></a>3.局部内部类（ 定义在方法中的类）</h2><p>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-匿名内部类（-要继承一个父类或者实现一个接口、直接使用new-来生成一个对象的引用）"><a href="#4-匿名内部类（-要继承一个父类或者实现一个接口、直接使用new-来生成一个对象的引用）" class="headerlink" title="4.匿名内部类（ 要继承一个父类或者实现一个接口、直接使用new 来生成一个对象的引用）"></a>4.匿名内部类（ 要继承一个父类或者实现一个接口、直接使用new 来生成一个对象的引用）</h2><p>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一<br>个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引<br>用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Bird bird)</span></span>&#123;</span><br><span class="line">System.out.println(bird.getName() + <span class="string">"能够飞 "</span> + bird.fly() + <span class="string">"米"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.test(<span class="keyword">new</span> Bird() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"大雁"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>克隆</title>
      <link href="/%E5%85%8B%E9%9A%86.html"/>
      <url>/%E5%85%8B%E9%9A%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><p>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式<br>是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</p><a id="more"></a><h2 id="1-直接赋值复制"><a href="#1-直接赋值复制" class="headerlink" title="1.直接赋值复制"></a>1.直接赋值复制</h2><p>直接赋值。在 Java 中， A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候， a2 里面的成员变量也会跟<br>着变化。</p><h2 id="2-浅复制（-复制引用但不复制引用的对象）"><a href="#2-浅复制（-复制引用但不复制引用的对象）" class="headerlink" title="2.浅复制（ 复制引用但不复制引用的对象）"></a>2.浅复制（ 复制引用但不复制引用的对象）</h2><p>创建一个新对象，然后将当前对象的非静态字段复制到该新对象， 如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (Resume)<span class="keyword">super</span>.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-深复制（复制对象和其应用对象）"><a href="#3-深复制（复制对象和其应用对象）" class="headerlink" title="3.深复制（复制对象和其应用对象）"></a>3.深复制（复制对象和其应用对象）</h2><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">Professor p;</span><br><span class="line"></span><br><span class="line">Student(String name, <span class="keyword">int</span> age, Professor p) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.p = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student o = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">o = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">System.out.println(e.toString());</span><br><span class="line">&#125;</span><br><span class="line">o.p = (Professor) p.clone();</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-序列化（-深-clone-一中实现）"><a href="#4-序列化（-深-clone-一中实现）" class="headerlink" title="4.序列化（ 深 clone 一中实现）"></a>4.序列化（ 深 clone 一中实现）</h2><p>在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/%E6%B3%9B%E5%9E%8B.html"/>
      <url>/%E6%B3%9B%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本<br>质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 比如我们要写一个排序方法，<br>能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。</p><a id="more"></a><h2 id="1-泛型方法（-）"><a href="#1-泛型方法（-）" class="headerlink" title="1.泛型方法（ ）"></a>1.泛型方法（ <E>）</h2><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数<br>类型，编译器适当地处理每一个方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">System.out.printf( <span class="string">"%s "</span>, element );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型边界"><a href="#泛型边界" class="headerlink" title="泛型边界"></a>泛型边界</h3><ol><li>&lt;? extends T&gt;表示该通配符所代表的类型是 T 类型的子类。</li><li>&lt;? super T&gt;表示该通配符所代表的类型是 T 类型的父类。</li></ol><h2 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2.泛型类"></a>2.泛型类<T></h2><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一<br>样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，<br>也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，<br>这些类被称为参数化的类或参数化的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T t;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.t = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-类型通配符"><a href="#3-类型通配符" class="headerlink" title="3.类型通配符?"></a>3.类型通配符?</h2><p>类 型 通 配 符 一 般 是 使 用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在 逻 辑 上 是<br>List<String>,List<Integer> 等所有 List&lt;具体类型实参&gt;的父类。</p><h2 id="4-类型擦除"><a href="#4-类型擦除" class="headerlink" title="4.类型擦除"></a>4.类型擦除</h2><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛<br>型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个<br>过程就称为类型擦除。如在代码中定义的 List<Object>和 List<String>等类型，在编译之后<br>都会变成 List。 JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。<br>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般<br>是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换<br>成具体的类。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射基础</title>
      <link href="/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80.html"/>
      <url>/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA反射基础"><a href="#JAVA反射基础" class="headerlink" title="JAVA反射基础"></a>JAVA反射基础</h1><h2 id="1-动态语言"><a href="#1-动态语言" class="headerlink" title="1.动态语言"></a>1.动态语言</h2><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的JavaScript就是动态语言，除此之外Ruby,Python等也属于动态语言，而C、C++则不属于动态语言。从反射角度说JAVA属于半动态语言。</p><a id="more"></a><h2 id="2-反射机制概念-（运行状态中知道类所有的属性和方法）"><a href="#2-反射机制概念-（运行状态中知道类所有的属性和方法）" class="headerlink" title="2.反射机制概念 （运行状态中知道类所有的属性和方法）"></a>2.反射机制概念 （运行状态中知道类所有的属性和方法）</h2><p>图取自网上<br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20200424094000.png" alt=""><br>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p><h2 id="3-反射的应用场合"><a href="#3-反射的应用场合" class="headerlink" title="3.反射的应用场合"></a>3.反射的应用场合</h2><p>编译时类型和运行时类型 在Java程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> JeepCar();</span><br></pre></td></tr></table></figure><p>其中编译时类型Car，运行时类型为JeepCar。</p><p>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p><h2 id="4-Java反射API"><a href="#4-Java反射API" class="headerlink" title="4.Java反射API"></a>4.Java反射API</h2><p>反射API用来生成JVM中的类、接口或则对象的信息。</p><ol><li>Class类：反射的核心类，可以获取类的属性，方法等信息。</li><li>Field类：Java.lang.reflec包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li>Method类： Java.lang.reflec包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li>Constructor类： Java.lang.reflec包中的类，表示类的构造方法。</li></ol><h2 id="5-反射使用步骤（获取Class对象、调用对象方法）"><a href="#5-反射使用步骤（获取Class对象、调用对象方法）" class="headerlink" title="5.反射使用步骤（获取Class对象、调用对象方法）"></a>5.反射使用步骤（获取Class对象、调用对象方法）</h2><ol><li>获取想要操作的类的Class对象，他是反射的核心，通过Class对象我们可以任意调用类的方法。 </li><li>调用Class类中的方法，既就是反射的使用阶段。 </li><li>使用反射API来操作这些信息。</li></ol><h2 id="6-获取Class对象的3种方法"><a href="#6-获取Class对象的3种方法" class="headerlink" title="6.获取Class对象的3种方法"></a>6.获取Class对象的3种方法</h2><p>调用某个对象的getClass()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car car=<span class="keyword">new</span> Car(); </span><br><span class="line">Class clazz=car.getClass();</span><br></pre></td></tr></table></figure><p>调用某个类的class属性来获取该类对应的Class对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz= Car<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure><p>使用Class类中的forName()静态方法(最安全/性能最好) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(最常用) </span></span><br><span class="line">Class clazz=Class.forName(<span class="string">"类的全路径"</span>);</span><br></pre></td></tr></table></figure><p> 当我们获得了想要操作的类的Class对象后，可以通过Class类中的方法获取并查看该类中的方法和属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Car类的Class对象</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.demo.Car"</span>);</span><br><span class="line"><span class="comment">//获取Car类的所有方法信息 </span></span><br><span class="line">Method[] method=clazz.getDeclaredMethods(); </span><br><span class="line"><span class="keyword">for</span>(Method m:method)&#123;</span><br><span class="line">System.out.println(m.toString());</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//获取Person类的所有成员属性信息 </span></span><br><span class="line">Field[] field=clazz.getDeclaredFields(); </span><br><span class="line"><span class="keyword">for</span>(Field f:field)&#123;</span><br><span class="line">System.out.println(f.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Car类的所有构造方法</span></span><br><span class="line">Constructor[] constructor=clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor c:constructor)&#123;</span><br><span class="line">System.out.println(c.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-创建对象的两种方法"><a href="#7-创建对象的两种方法" class="headerlink" title="7.创建对象的两种方法"></a>7.创建对象的两种方法</h2><p>Class对象的newInstance()</p><ol><li>使用Class对象的newInstance()方法来创建该Class对象对应类的实例，但是这种方法要求该Class对象对应的类有默认的空构造器。调用Constructor对象的newInstance()</li><li>先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建 Class对象对应类的实例,通过这种方法可以选定构造方法创建实例。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Person类的Class对象 </span></span><br><span class="line">Class clazz=Class.forName(<span class="string">"com.demo.Person"</span>);</span><br><span class="line"><span class="comment">//使用.newInstane方法创建对象 </span></span><br><span class="line">Car car= (Car) clazz.newInstance(); </span><br><span class="line"><span class="comment">//获取构造方法并创建对象</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>; </span><br><span class="line"><span class="comment">//创建对象并设置属性</span></span><br><span class="line">Car car1 =(Car) c.newInstance(<span class="string">"Jeep"</span>,<span class="string">"黑色"</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
