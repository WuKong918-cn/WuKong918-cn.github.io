<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/Java_256px.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Java_32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Java_16px.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="\lib\font-awesome\css\font-awesome.css">
  <link rel="stylesheet" href="\lib\fancybox\source\jquery.fancybox.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>


  <meta name="keywords" content="404 Not Found：该页无法显示" />




<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.wukong918.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVM整体结构 字节码的作用是什么？为什么需要字节码？  字节码是通用的，在不同的平台上的JVM均能运行 增加字节码的概念后，产生了更多简便好用的高级语言例如Groovy，Scala，Kotlin，JRuby，如果Java是解释性语言（无字节码解耦）那么将不会有这么多的扩展。 Java语言更加高级，如果不编译成为字节码，直接使用代码交给解释器去翻译成为机器指令效率较低，这种模式和Python类似。">
<meta property="og:type" content="article">
<meta property="og:title" content="效率学会JVM">
<meta property="og:url" content="https://www.wukong918.cn/jvm/%E6%95%88%E7%8E%87%E5%AD%A6%E4%BC%9AJVM.html">
<meta property="og:site_name" content="悟空的博客">
<meta property="og:description" content="JVM整体结构 字节码的作用是什么？为什么需要字节码？  字节码是通用的，在不同的平台上的JVM均能运行 增加字节码的概念后，产生了更多简便好用的高级语言例如Groovy，Scala，Kotlin，JRuby，如果Java是解释性语言（无字节码解耦）那么将不会有这么多的扩展。 Java语言更加高级，如果不编译成为字节码，直接使用代码交给解释器去翻译成为机器指令效率较低，这种模式和Python类似。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116180032.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116180429.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116214710.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116221359.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116221607.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116221916.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116223156.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116224202.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117124647.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117133719.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117135600.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117144555.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117144914.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117145917.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117150720.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117151541.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117151953.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117154729.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117155119.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117155836.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117164552.png">
<meta property="og:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117164956.png">
<meta property="article:published_time" content="2024-11-15T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-18T05:19:06.679Z">
<meta property="article:author" content="悟空">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="效率">
<meta property="article:tag" content="解释器">
<meta property="article:tag" content="JIT">
<meta property="article:tag" content="字节码">
<meta property="article:tag" content="运行时数据区">
<meta property="article:tag" content="执行引擎">
<meta property="article:tag" content="类加载">
<meta property="article:tag" content="垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116180032.png">

<link rel="canonical" href="https://www.wukong918.cn/jvm/%E6%95%88%E7%8E%87%E5%AD%A6%E4%BC%9AJVM.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>效率学会JVM | 悟空的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="悟空的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">悟空的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活中遇到的，学习到的一些开发技巧</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>联系我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wukong918.cn/jvm/%E6%95%88%E7%8E%87%E5%AD%A6%E4%BC%9AJVM.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201124192552.jpeg">
      <meta itemprop="name" content="悟空">
      <meta itemprop="description" content="学得越多会得越少">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="悟空的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          效率学会JVM
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-16 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-16T00:00:00+08:00">2024-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h1><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116180032.png" alt="JVM整体结构"></p>
<h1 id="字节码的作用是什么？为什么需要字节码？"><a href="#字节码的作用是什么？为什么需要字节码？" class="headerlink" title="字节码的作用是什么？为什么需要字节码？"></a>字节码的作用是什么？为什么需要字节码？</h1><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116180429.png" alt="字节码的图片"></p>
<ol>
<li>字节码是通用的，在不同的平台上的JVM均能运行</li>
<li>增加字节码的概念后，产生了更多简便好用的高级语言例如<code>Groovy</code>，<code>Scala</code>，<code>Kotlin</code>，<code>JRuby</code>，如果Java是解释性语言（无字节码解耦）那么将不会有这么多的扩展。</li>
<li>Java语言更加高级，如果不编译成为字节码，直接使用代码交给解释器去翻译成为机器指令效率较低，这种模式和Python类似。如果编译成为字节码之后，JVM去解释为机器指令效率会比较高，将性能通过提前编译的形式来提高运行时的效率。<a id="more"></a>
<h1 id="类加载子系统是什么？如何工作的？"><a href="#类加载子系统是什么？如何工作的？" class="headerlink" title="类加载子系统是什么？如何工作的？"></a>类加载子系统是什么？如何工作的？</h1><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116214710.png" alt="类加载子系统是什么？如何工作的？"></li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证待加载的class文件是否正确，比如验证文件格式</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为static变量分配内存并赋零值（int = 0， boolean默认为false等）</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将符号引用解析为直接引用，将变量指向方法区中的内存地址</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>将static的变量赋予我们代码中指定的值</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>BootSrapClassLoader：负责加载 jre/lib下的类</p>
<h3 id="JDK自定义加载器-继承实现ClassLoader类"><a href="#JDK自定义加载器-继承实现ClassLoader类" class="headerlink" title="JDK自定义加载器(继承实现ClassLoader类)"></a>JDK自定义加载器(继承实现ClassLoader类)</h3><p><code>ExtCLassLoader</code>：负责加载jre/lib/ext目录下的类<br><code>AppClassLoader</code>：负责加载应用指定classpath的自定义类或者引用的jar包下的类</p>
<h3 id="类加载器分类的总结"><a href="#类加载器分类的总结" class="headerlink" title="类加载器分类的总结"></a>类加载器分类的总结</h3><p>不同的类加载器，主要负责的目录不同</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116221359.png" alt="初始化类加载器"><br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116221607.png" alt="初始化AppClassLoader"><br>这两张图中，表示了Launcher在初始化时会先加载ExtClassLoader并把ExtClassLoader对象当作AppClassLoader的parent依次传递到ClassLoader类中赋值parent变量</p>
<p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116221916.png" alt="AppClassLoader重写了loadClass方法"><br>这张图的方法为AppClassLoader重写了ClassLoader的loadClass方法，并在最后调用了ClassLoader.loadClass方法，之后将进入双亲委派的逻辑</p>
<p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116223156.png" alt="loadClass"><br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241116224202.png" alt="findClass"><br>这两张图表示了双亲委派的流程，AppClassLoader会调用ExtClassLoader.loadClass，ExtClassLoader的loadClass会去调用BootStrapClassLoader去寻找类，在我们自定义类在被加载时，BootStrapClassLoader是无法加载的所以返回为null。此时会走到ExtCLassLoader的findClass，因为ExtCLassLoader继承URLClassLoader并且没有重写该方法所以使用的URLClassLoader.findClass。ExtClassLoader无法找到类就抛出了ClassNotFound的异常，此时方法就会回到AppClassLoader调用的loadClass方法的catch异常块，后续走到AppClassLoader继续寻找类。因为在AppClassLoader在调用loadClass时是校验过是否能获取到类的，所以此处findClass方法一定能找到类。（AppClassLoader同样继承URLClassLoader）</p>
<p>双亲委派机制之所以叫“双亲委派”，是因为在类加载的过程中，子加载器会将类加载请求委托给父加载器。如果父加载器无法找到该类，才由子加载器尝试加载。“双亲”指的就是这些类加载器之间的父子关系。</p>
<p><code>双亲委派的作用</code>：避免类的重复加载，防止核心API被篡改（核心API是由BootStrapClassLoader或ExtClassLoader加载的）。</p>
<h3 id="Tomcat为什么要自定义类加载器"><a href="#Tomcat为什么要自定义类加载器" class="headerlink" title="Tomcat为什么要自定义类加载器"></a>Tomcat为什么要自定义类加载器</h3><p>为了进行类的隔离，如果Tomcat直接使用AppClassLoader类加载类，那就会出现以下情况</p>
<ol>
<li>应用A中有一个com.wukong918.Hello.class</li>
<li>应用B中也有一个com.wukong918.Hello.class</li>
<li>虽然都叫Hello，但是具体的方法、属性可能不一样</li>
<li>如果AppClassLoader先加载了应用A中的Hello.class</li>
<li>那么应用B中的Hello.class就不可能再被加载了，因为名字是一样</li>
<li>如果就需要针对应用A和应用B设置各自单独的类加载器，也就是WebappClassLoader(不同应用就生成不同的WebappClassLoader对象)</li>
<li>这样两个应用的Hello.class都能被各自的类加载器所加载，不会冲突</li>
<li>这就是Tomcat为什么用自定义类加载器的核心原因，为了实现类加载的隔离</li>
<li><font color="red">JVM中判断一个类是不是已经被加载的逻辑是：类名+对应的类加载器实例</font> </li>
</ol>
<h3 id="自定义类加载器的使用场景"><a href="#自定义类加载器的使用场景" class="headerlink" title="自定义类加载器的使用场景"></a>自定义类加载器的使用场景</h3><p>1、实现类似进程内隔离：<br>类加载器实际上可以用作不同的命名空间，以提供类似容器、模块化的效果。例如，当两个模块依赖于某个类库的不同版本时，如果它们分别被不同的容器加载，就可以互不干扰。这种应用场景在JavaEE、OSGI、JPMS等框架中非常常见。</p>
<p>2、从非标准的来源加载代码：<br>如果应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统，或者需要自己操纵字节码，动态修改或生成类型，那么自定义类加载器就派上了用场。</p>
<p>3、加密和安全性：<br>Java代码可以轻易地被反编译。如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，然后在加载类的时候使用自定义的类加载器先解密类，再加载。这样可以提高代码的安全性。</p>
<p>4、打破双亲委派模型：<br>在某些特殊情况下，你可能需要打破Java的双亲委派模型。例如，在热部署、插件系统或某些特定的类隔离场景中，你可能需要自定义类加载器来绕过双亲委派模型。</p>
<p>5、动态性和灵活性：<br>类加载器可以在运行时根据需要加载类，而不需要提前知道类名。这使得它适用于动态加载插件、扩展机制等场景。同时，类加载器可以从自定义的位置加载类文件，例如从网络、数据库或其他非标准位置加载类，这在一些特殊需求的情况下更为适用。</p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117124647.png" alt="运行时数据区图"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>PC Register，程序计寄存器，简称为程序计数器.每个线程一个程序计数器。</p>
<ol>
<li>是物理寄存器的抽象实现</li>
<li>用来记录待执行的下一条指令的地址</li>
<li>它是程序控制流的指示器，循环、if else、异常处理、线程恢复等都依赖它来完成</li>
<li>解释器工作时就是通过它来获取下一条需要执行的字节码指令的</li>
<li>它是唯一一个在JVM规范中没有任何OutOfMemoryError情况的区域</li>
</ol>
<h2 id="虚拟机栈（Java栈、Java方法栈）"><a href="#虚拟机栈（Java栈、Java方法栈）" class="headerlink" title="虚拟机栈（Java栈、Java方法栈）"></a>虚拟机栈（Java栈、Java方法栈）</h2><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117133719.png" alt="栈的执行流程图"><br>每个线程在创建时都会创建一个虚拟机栈，栈内会保存一个个的栈帧，每个栈帧对应一个方法。</p>
<ol>
<li>虚拟机栈时线程私有的</li>
<li>一个方法开始执行栈帧入栈，方法执行完对应的栈帧就出栈，所以虚拟机栈不需要进行垃圾回收</li>
<li>虚拟机栈存在OutOfMemoryError，以及StackOverflowError</li>
<li>线程太多，就可能会出现OutOfMemoryError，线程创建时没有足够的内存去创建虚拟机栈了</li>
<li>方法调用层次太多了，就可能出现StackOverflowError</li>
<li>可以通过 -Xss来设置虚拟机栈大小</li>
</ol>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>就像一个 记事本，用来记下当前方法中所有需要的数据（如参数和局部变量）。比如你写了一个方法，方法有一些参数，方法内也可能会有一些临时变量。JVM 会把这些数据放进这个“记事本”里，方便后面随时查阅和使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleMethod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;  <span class="comment">// c 就是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行 <code>exampleMethod</code> 方法时，JVM 会把 <code>a</code>、<code>b</code> 和 <code>c</code> 存放在局部变量表里，方便随时取出来用。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>这个就像一个<strong>临时工作台</strong>，用来放暂时需要计算的数字。方法中可能会进行一些计算，比如加法、减法等，操作数栈就是用来存放计算过程中使用的数据。例如，你要计算 <code>a + b</code>，JVM 会把 <code>a</code> 和 <code>b</code> 放在操作数栈上，计算完成后，结果就会放回去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = a + b;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>a</code> 和 <code>b</code> 会被放到操作数栈里，执行完加法运算后的会被放回操作数栈里。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>这部分就像是 <code>导航地图</code>，用来告诉程序怎么找到你调用的那些方法或变量。JVM 在执行方法时，并不是直接知道方法的具体位置，而是根据方法名和参数去 常量池 中查找方法的地址，找到后才去执行。这就是动态链接，它确保每次执行时都能正确地找到方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someMethod();  <span class="comment">// 在运行时，JVM 会找到 this method 对应的实现并执行</span></span><br></pre></td></tr></table></figure>
<p>JVM 会去常量池中找到 <code>someMethod</code> 方法的地址，然后跳转执行。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>这个就是 <code>回家的路</code>，每当你调用一个方法时，JVM 会记下你从哪里来（即调用这个方法的地方）。当方法执行完毕后，它会用这个地址“回到原来的地方”，继续执行下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    methodB();  <span class="comment">// methodA 会记下调用 methodB 后，接着执行的方法是哪里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>methodB</code> 执行完后，JVM 就会跳转回 <code>methodA</code> 执行后续的操作。这就是方法返回地址的作用。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法：native method，在Java中定义的方法，但由其他语言实现<br>虚拟机栈存的事Java方法调用过程的栈帧，本地方法栈存的是本地方法调用过程中的栈帧。<br>也是线程私有的，也可能会出现OOM和StackOverFlowError</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117135600.png" alt="堆数据结构图"><br>-Xms： ms（memory start），指定堆的初始化内存大小，等价于—XX:InitialHeapSize</p>
<p>-Xmx: mx(memory max)，指定堆的最大内存大小，等价于-XX:MaxHeapSize</p>
<p>一般会把-Xms和-Xmx设置一样，这样JVM就不需要在GC后去修改堆的内存大小了，提高了效率。<br>默认情况下，初始化内存大小=物理内存大小/64，最大内存大小=物理内存大小/4.</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>可以通过-XX:NewRatio 参数来配置新生代和老年代（元空间）的比例，默认为2，表示新生代占1，老年代占2，也就是新生代占堆区总大小的1/3。<br>一般不需要调整该参数，只有明确知道存活时间比较长的对象偏多，那么就需要调大NewRatio，从而调整老年代的占比。</p>
<h3 id="Eden和S0、S1"><a href="#Eden和S0、S1" class="headerlink" title="Eden和S0、S1"></a>Eden和S0、S1</h3><p>Eden：伊甸园区，新对象都会先放到Eden区域（除非对象的大小都超过了Eden区，那么就只能直接放进老年代）<br>S0、S1：Survivor0、Survivor1区，也可以叫做from区、to区(复制整理内存块)或者幸存区，用来存放MinorGC（YGC【Young GC】）后存在的对象。</p>
<p>默认情况下（Eden区、S0区、S1区）的比例关系为（8:1:1），也就是Eden区占新生代大小的8/10可以通过-XX:SurvivorRatio来调整。<br><font color="red"><br>对象最多经历15次垃圾回收则会进入到老年代，不是指一定会经历15次垃圾回收而是指最大经历15次垃圾回收，因为对象头中的标记经历垃圾回收的标记位为二进制4位最大（1111）<br></font></p>
<h3 id="堆内对象的生命周期"><a href="#堆内对象的生命周期" class="headerlink" title="堆内对象的生命周期"></a>堆内对象的生命周期</h3><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=561925300&bvid=BV1he4y1e7nW&cid=871007682&p=16" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="JVM-中的解释器详解"><a href="#JVM-中的解释器详解" class="headerlink" title="JVM 中的解释器详解"></a>JVM 中的解释器详解</h3><p>在 <strong>Java 虚拟机（JVM）</strong> 中，解释器（Interpreter）是一个核心组件，负责直接解释执行 Java 字节码（Bytecode）。解释器逐条读取并翻译字节码指令，将其转换为底层硬件可以理解的机器指令并立即执行。它是 JVM 实现跨平台特性和快速启动应用的重要组成部分。</p>
<h3 id="解释器的核心功能"><a href="#解释器的核心功能" class="headerlink" title="解释器的核心功能"></a>解释器的核心功能</h3><ol>
<li><p><strong>逐条解释执行字节码</strong></p>
<ul>
<li>JVM 的解释器会按照字节码的顺序逐条读取并执行每条指令。</li>
<li>例如，字节码指令 <code>iload_1</code> 表示将本地变量表中的某个整数加载到操作数栈，而 <code>iadd</code> 表示从栈中弹出两个整数进行相加。</li>
</ul>
</li>
<li><p><strong>字节码到机器指令的即时翻译</strong></p>
<ul>
<li>每一条字节码指令被解释器翻译为与当前运行环境相关的机器指令，然后在目标硬件上立即执行。</li>
<li>翻译与执行是一气呵成的，而不涉及生成本地代码文件。</li>
</ul>
</li>
<li><p><strong>跨平台执行</strong></p>
<ul>
<li>字节码是 Java 的中间表示，不依赖具体硬件。解释器的作用是为字节码提供适配具体平台的执行能力，从而实现 <strong>“一次编写，到处运行”</strong>。</li>
</ul>
</li>
</ol>
<h3 id="JVM-解释器的执行流程"><a href="#JVM-解释器的执行流程" class="headerlink" title="JVM 解释器的执行流程"></a>JVM 解释器的执行流程</h3><p>解释器的执行流程包括以下几个步骤：</p>
<ol>
<li><p><strong>加载字节码</strong></p>
<ul>
<li>JVM 加载 <code>.class</code> 文件，将字节码存储在方法区中。</li>
<li>字节码是以指令序列的形式保存的。</li>
</ul>
</li>
<li><p><strong>初始化栈帧</strong></p>
<ul>
<li>JVM 为每个线程分配一个独立的 <strong>栈帧（Stack Frame）</strong>。</li>
<li>栈帧包含局部变量表、操作数栈等，用于存储方法调用时的运行时信息。</li>
</ul>
</li>
<li><p><strong>逐条解释字节码指令</strong></p>
<ul>
<li>解释器读取方法中的每条字节码指令，并执行相应的操作。例如：<ul>
<li><code>iload_1</code>：从局部变量表中加载一个整数到操作数栈。</li>
<li><code>iadd</code>：从操作数栈中弹出两个整数，进行加法运算并将结果压回栈。</li>
<li><code>invokevirtual</code>：调用实例方法，并创建新的栈帧处理方法调用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果或异常处理</strong></p>
<ul>
<li>每个方法的执行会返回结果（或异常）。解释器通过栈帧的管理机制将返回值交回调用方法。</li>
</ul>
</li>
</ol>
<h3 id="解释器的优点与缺点"><a href="#解释器的优点与缺点" class="headerlink" title="解释器的优点与缺点"></a>解释器的优点与缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li><strong>启动速度快：</strong><ul>
<li>不需要耗时的预编译步骤，字节码可以直接执行，尤其适合短时间运行的程序。</li>
</ul>
</li>
<li><strong>实现简单：</strong><ul>
<li>解释器的实现逻辑相对简单，与底层硬件无关，方便跨平台部署。</li>
</ul>
</li>
<li><strong>内存占用低：</strong><ul>
<li>不需要生成或缓存大量的本地代码，因此运行时内存占用更少。</li>
</ul>
</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li><strong>执行效率低：</strong><ul>
<li>每次执行字节码时都需要进行翻译，这种重复操作会产生显著的性能开销。</li>
</ul>
</li>
<li><strong>缺乏优化能力：</strong><ul>
<li>解释器难以对热点代码进行深度优化，例如内联函数调用、消除冗余检查等。</li>
</ul>
</li>
<li><strong>无法充分利用硬件资源：</strong><ul>
<li>与编译后的机器码相比，解释执行无法充分优化 CPU 寄存器、指令流水线等资源。</li>
</ul>
</li>
</ol>
<h3 id="解释器在-JVM-中的角色"><a href="#解释器在-JVM-中的角色" class="headerlink" title="解释器在 JVM 中的角色"></a>解释器在 JVM 中的角色</h3><p>在现代 JVM（如 HotSpot JVM）中，解释器通常与 <strong>JIT 编译器</strong> 配合使用，共同实现性能优化：</p>
<ol>
<li><p><strong>初始执行：解释器优先</strong></p>
<ul>
<li>JVM 在启动时，直接使用解释器运行字节码，从而快速启动程序。</li>
</ul>
</li>
<li><p><strong>热点代码：交由 JIT 编译器</strong></p>
<ul>
<li>JVM 通过性能分析器（Profiler）检测到热点代码后，将这些代码交由 JIT 编译器编译为高效的机器码。</li>
</ul>
</li>
<li><p><strong>分层编译</strong></p>
<ul>
<li>现代 JVM 实现了多层次的优化策略。例如：<ul>
<li>初级：使用解释器执行。</li>
<li>中级：简单的 JIT 编译。</li>
<li>高级：复杂的 JIT 优化（如逃逸分析、内联等）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="JVM-解释器的实现方式"><a href="#JVM-解释器的实现方式" class="headerlink" title="JVM 解释器的实现方式"></a>JVM 解释器的实现方式</h3><p>解释器的实现方式取决于 JVM 的具体版本和设计目标，以下是两种常见实现：</p>
<ol>
<li><p><strong>基于字节码的解释器</strong></p>
<ul>
<li>逐条解析字节码指令并直接执行。</li>
<li>实现简单，但每条字节码指令都需解析多次，运行效率较低。</li>
</ul>
</li>
<li><p><strong>基于模板的解释器</strong></p>
<ul>
<li>为每种字节码指令预定义一组机器指令模板。</li>
<li>执行字节码时，直接引用相应的模板指令以提高执行效率。</li>
<li>HotSpot JVM 使用这种解释器实现方式。</li>
</ul>
</li>
</ol>
<h3 id="JVM-解释器的优化策略"><a href="#JVM-解释器的优化策略" class="headerlink" title="JVM 解释器的优化策略"></a>JVM 解释器的优化策略</h3><p>即使在解释执行的场景下，JVM 解释器也会采用一些策略来提升性能：</p>
<ol>
<li><p><strong>指令预取</strong></p>
<ul>
<li>在解释执行时提前加载多条字节码指令，减少解释器的指令读取时间。</li>
</ul>
</li>
<li><p><strong>简化指令解析</strong></p>
<ul>
<li>为常见字节码指令设置快速路径。例如：<ul>
<li>加载/存储指令（<code>iload</code>, <code>istore</code>）；</li>
<li>运算指令（<code>iadd</code>, <code>imul</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地化数据结构</strong></p>
<ul>
<li>通过优化字节码的操作数栈和局部变量表的访问方式，减少访问延迟。</li>
</ul>
</li>
</ol>
<h3 id="JVM-解释器的实际应用场景"><a href="#JVM-解释器的实际应用场景" class="headerlink" title="JVM 解释器的实际应用场景"></a>JVM 解释器的实际应用场景</h3><ol>
<li><p><strong>轻量级应用</strong></p>
<ul>
<li>小型程序（如脚本、工具类应用）可以直接依赖解释器快速启动和执行。</li>
</ul>
</li>
<li><p><strong>调试与开发</strong></p>
<ul>
<li>解释器逐条执行代码，方便开发者追踪代码执行逻辑和发现错误。</li>
</ul>
</li>
<li><p><strong>虚拟机的跨平台适配</strong></p>
<ul>
<li>在新平台上实现一个解释器比实现一个 JIT 编译器简单得多，因此解释器是跨平台的首选解决方案。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JVM 中的解释器是虚拟机运行 Java 字节码的重要模块，通过逐条解释执行字节码指令，帮助实现跨平台特性和快速启动。然而，由于其运行效率较低，现代 JVM 通常结合 JIT 编译器协同工作，最大限度地提升 Java 应用的运行性能。解释器的作用不可忽视，特别是在应用启动和轻量级任务中，它为 JVM 提供了基础的执行能力。</p>
<h2 id="JIT（Just-In-Time）编译器"><a href="#JIT（Just-In-Time）编译器" class="headerlink" title="JIT（Just-In-Time）编译器"></a>JIT（Just-In-Time）编译器</h2><h3 id="JIT-编译器概述"><a href="#JIT-编译器概述" class="headerlink" title="JIT 编译器概述"></a>JIT 编译器概述</h3><p>JIT（Just-In-Time）编译器是一种 <strong>动态编译技术</strong>，它在程序运行时将中间表示形式（如字节码）转换为机器码，从而提高程序的执行效率。与传统的 <strong>静态编译器</strong> 不同，JIT 编译器不会在程序运行前生成机器码，而是在运行过程中根据需要进行动态编译，并将已编译的代码缓存起来以供重复使用。</p>
<p>JIT 编译器通常与 <strong>虚拟机</strong>（如 Java 虚拟机或 .NET CLR）协同工作，是现代高效运行时系统的核心组件之一。它结合了解释执行和静态编译的优点，既能灵活应对不同运行环境，又能提供接近本地编译代码的性能。</p>
<h3 id="JIT-编译器的工作原理"><a href="#JIT-编译器的工作原理" class="headerlink" title="JIT 编译器的工作原理"></a>JIT 编译器的工作原理</h3><ol>
<li><p><strong>解释执行：</strong></p>
<ul>
<li>程序启动时，虚拟机会优先使用解释器逐行解释字节码。解释执行不需要额外编译步骤，因此启动快，但执行速度较慢。</li>
</ul>
</li>
<li><p><strong>热点探测：</strong></p>
<ul>
<li>JIT 编译器监控程序的运行状态，收集执行频率和调用关系等信息。被频繁执行的代码片段（即“热点代码”）会被标记为优化对象。</li>
</ul>
</li>
<li><p><strong>即时编译：</strong></p>
<ul>
<li>对热点代码，JIT 编译器将其字节码编译为本地机器码。这个过程通常只发生一次，随后对相同代码的执行直接调用机器码，从而显著提升执行速度。</li>
</ul>
</li>
<li><p><strong>缓存和优化：</strong></p>
<ul>
<li>编译后的机器码会被缓存，以便重复使用。此外，JIT 编译器会根据运行时的信息对代码进行优化，例如：<ul>
<li><strong>内联优化：</strong> 将小型函数的调用直接展开到调用处，减少函数调用开销。</li>
<li><strong>冗余消除：</strong> 移除无效或多余的计算。</li>
<li><strong>循环优化：</strong> 针对循环结构进行展开或合并。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="JIT-编译器的优势"><a href="#JIT-编译器的优势" class="headerlink" title="JIT 编译器的优势"></a>JIT 编译器的优势</h3><ol>
<li><p><strong>动态优化：</strong></p>
<ul>
<li>JIT 编译器能够利用运行时信息（如内存访问模式、方法调用频率）进行动态优化，生成针对当前负载的高效代码。</li>
</ul>
</li>
<li><p><strong>平台无关性：</strong></p>
<ul>
<li>原始程序以字节码或中间语言形式分发，由虚拟机通过 JIT 编译为目标平台的本地代码，从而实现“一次编写，到处运行”。</li>
</ul>
</li>
<li><p><strong>代码复用：</strong></p>
<ul>
<li>已编译的热点代码可缓存并重复使用，避免每次执行都重新解释，提高运行效率。</li>
</ul>
</li>
<li><p><strong>调试和诊断支持：</strong></p>
<ul>
<li>动态编译允许嵌入调试信息，方便开发人员实时分析和优化程序性能。</li>
</ul>
</li>
</ol>
<h3 id="JIT-编译器的挑战"><a href="#JIT-编译器的挑战" class="headerlink" title="JIT 编译器的挑战"></a>JIT 编译器的挑战</h3><ol>
<li><p><strong>启动性能：</strong></p>
<ul>
<li>程序运行初期，解释执行和即时编译可能会引入额外开销，导致启动速度比纯解释或静态编译慢。</li>
</ul>
</li>
<li><p><strong>内存占用：</strong></p>
<ul>
<li>编译生成的机器码需要额外的内存空间进行存储，对内存资源较为敏感。</li>
</ul>
</li>
<li><p><strong>实现复杂性：</strong></p>
<ul>
<li>为了实现动态优化和平台适配，JIT 编译器的实现难度较高，可能涉及复杂的指令优化算法和硬件特性支持。</li>
</ul>
</li>
<li><p><strong>高频代码切换：</strong></p>
<ul>
<li>在多线程高并发环境中，热点代码的频繁编译和切换可能会带来额外的开销，甚至引发性能波动。</li>
</ul>
</li>
</ol>
<h3 id="JIT-编译器的优化技术"><a href="#JIT-编译器的优化技术" class="headerlink" title="JIT 编译器的优化技术"></a>JIT 编译器的优化技术</h3><ol>
<li><p><strong>分层编译（Tiered Compilation）：</strong></p>
<ul>
<li>将编译分为多个层级，例如简单优化和深度优化。初始使用解释器执行，随着代码热度升高逐渐编译为高效机器码。</li>
</ul>
</li>
<li><p><strong>逃逸分析（Escape Analysis）：</strong></p>
<ul>
<li>判断对象是否会逃逸出当前作用域。如果对象没有逃逸，可以将其分配到栈上而非堆上，从而减少垃圾回收的负担。</li>
</ul>
</li>
<li><p><strong>动态内联（Dynamic Inlining）：</strong></p>
<ul>
<li>将频繁调用的小方法展开为内联代码，减少方法调用的栈开销。</li>
</ul>
</li>
<li><p><strong>寄存器分配：</strong></p>
<ul>
<li>尽量将频繁访问的变量存储在寄存器中，减少内存访问次数。</li>
</ul>
</li>
<li><p><strong>死代码消除：</strong></p>
<ul>
<li>移除无法到达或不影响程序运行的代码，提升执行效率。</li>
</ul>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>JIT 编译器通过动态监测和即时优化，为解释执行和静态编译之间提供了一种高效的折中方案。虽然实现复杂且有一定的运行时开销，但它能够为现代虚拟机提供卓越的性能支持，是动态语言和虚拟机技术的重要基石。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><ul>
<li>Young GC/Minor GC：负责对新生代进行垃圾回收</li>
<li>Old GC/Major GC：负责对老年代进行垃圾回收，目前只有CMS垃圾收集器会单独对老年代进行垃圾收集，其他垃圾收集器基本都是整堆回收的时候对老年代进行垃圾收集</li>
<li>Full GC：整堆回收，也会对方法区进行垃圾收集<h3 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h3>垃圾是指在JVM中没有任何引用指向它的对象，如果不清理这些垃圾对象，那么它们就一直占用着内存，而不能给其他对象使用，最终垃圾对象越来越多，就会出现OOM</li>
</ul>
<h3 id="垃圾标记方法"><a href="#垃圾标记方法" class="headerlink" title="垃圾标记方法"></a>垃圾标记方法</h3><p>也就是找到JVM中（主要是堆中）有哪些垃圾对象，有两种方式：</p>
<ol>
<li>引用计数法</li>
<li>可达性分析法<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4>每个对象都保存一个引用计数器属性，用户记录对象被引用的次数。<br>优点：实现简单，计数器为0则表示是垃圾对象<br>缺点：</li>
<li>需要额外的空间来存储引用计数</li>
<li>需要额外的时间来维护引用计数</li>
<li><font color="red">无法处理循环依赖的问题</font><br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117144555.png" alt="引用计数法"><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4>可达性分析法会以<code>GC Roots</code>作为起始点，然后一层层找到所引用的对象，被找到的对象就是存活对象，那么其他不可达的对象就是垃圾对象。<br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117144914.png" alt="可达性分析法"><br>GC Roots是一组引用，包括：</li>
</ol>
<ul>
<li>线程中虚拟机栈（Java方法栈）中正在执行的方法中的参数、局部变量所对应的对象引用</li>
<li>线程中本地方法栈中正在执行的方法中的参数、局部变量所对应的对象引用</li>
<li>方法区中保存的类信息中静态属性所对应的对象引用</li>
<li>方法区中保存的类信息中常量属性所对应的对象引用</li>
<li>等等</li>
</ul>
<h3 id="垃圾对象回收算法"><a href="#垃圾对象回收算法" class="headerlink" title="垃圾对象回收算法"></a>垃圾对象回收算法</h3><h4 id="标记清除算法（Mark-Sweep）算法"><a href="#标记清除算法（Mark-Sweep）算法" class="headerlink" title="标记清除算法（Mark-Sweep）算法"></a>标记清除算法（Mark-Sweep）算法</h4><p>一种非常基础和常用的垃圾回收算法针对某块内存空间，比如新生代，老年代，如果可用内存不足后，就会STW（Stop The World），暂停用户线程的执行，然后执行算法进行垃圾回收：</p>
<ol>
<li>标记阶段：从GC Roots开始遍历，找到可达对象，并在对象头中进行记录</li>
<li>清除阶段：堆内存空间进行线性遍历，如果发现对象头中没有记录是可达对象，则回收它<br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117145917.png" alt="标记清除算法前后比较"></li>
</ol>
<p><em>缺点：</em></p>
<ol>
<li>效率不高</li>
<li>内存碎片(容易造成剩余内存足够，因为碎片造成无法放入较大的对象)</li>
</ol>
<p><em>优点：</em></p>
<ol>
<li>思路简单</li>
</ol>
<h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>将内存空间分为两块，每次指使用一块，在进行垃圾回收时，将可达对象复制到另外没有被使用的内存块中<code>并连续排列</code>，然后再清除当前内存块中所有对象，后续再按同样的流程进行垃圾回收，交替进行（Survivor From区、Survivor To区）。<br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117150720.png" alt="复制算法前后比较"></p>
<p><em>优点：</em></p>
<ol>
<li>没有标记和清除阶段，通过GC Roots找到可达对象，直接复制，不需要修改对象头，效率高</li>
<li>不会出现内存碎片</li>
</ol>
<p><em>缺点：</em></p>
<ol>
<li>需要更多的内存，始终有一半的内存空闲</li>
<li>对象复制后，对象存放的内存地址发生了变化，需要额外的时间修改栈帧中记录的引用地址</li>
<li>如果可达对象比较多，垃圾对象比较少，那么复制算法的效率比较低，所以垃圾对象多的情况下，复制算法比较合适（例如：新生代的幸存区【S0和S1区】）</li>
</ol>
<h4 id="标记-整理（Mark-Compact）算法"><a href="#标记-整理（Mark-Compact）算法" class="headerlink" title="标记-整理（Mark-Compact）算法"></a>标记-整理（Mark-Compact）算法</h4><ol>
<li>第一阶段和标记-清除算法一样，从GC Roots找到并标记可达对象</li>
<li>第二阶段将所有存活对象移动到内存的一端</li>
<li>清理边界外所有的空间<br><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117151541.png" alt="标记-整理（Mark-Compact）算法流程"></li>
</ol>
<p><em>优点：</em></p>
<ol>
<li>不会出现内存碎片</li>
<li>不需要额外的内存空间</li>
</ol>
<p><em>缺点：</em></p>
<ol>
<li>效率低于标记清除算法、复制算法</li>
<li>需要修改栈帧中的引用地址</li>
</ol>
<h4 id="标记清除、复制、标记整理三种算法对比"><a href="#标记清除、复制、标记整理三种算法对比" class="headerlink" title="标记清除、复制、标记整理三种算法对比"></a>标记清除、复制、标记整理三种算法对比</h4><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117151953.png" alt="标记清除、复制、标记整理三种算法对比"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>不同对象的存活时长是不一样的，也就可以针对不同的对象采取不同的垃圾回收算法。</p>
<p>默认几乎所有的垃圾收集器都是采用分代收集算法进行垃圾回收的。</p>
<p>我们会把堆分为新生代和老年代：</p>
<ul>
<li>新生代中的对象存活时间比较短，那么就可以利用复制算法，它适合垃圾对象比较多的情况。</li>
<li>老年代中的对象存活时间比较长，并且老年代的空间需求较高，所以不适合用复制算法（空间开销大），可以用标记清除或标记整理算法，比如：<ul>
<li>CMS垃圾收集器采用的就是标记清除算法</li>
<li>Serial Old垃圾收集器采用的就是标记整理算法</li>
</ul>
</li>
</ul>
<h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117154729.png" alt="常见的垃圾收集器"></p>
<h4 id="Parallel-GC和Parallel-Old-GC"><a href="#Parallel-GC和Parallel-Old-GC" class="headerlink" title="Parallel GC和Parallel Old GC"></a>Parallel GC和Parallel Old GC</h4><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117155119.png" alt="Parallel GC和Parallel Old GC"></p>
<h4 id="CMS（Concurrent-Mark-Sweep-Garbage-Collector-并发标记清除垃圾收集器）垃圾收集器"><a href="#CMS（Concurrent-Mark-Sweep-Garbage-Collector-并发标记清除垃圾收集器）垃圾收集器" class="headerlink" title="CMS（Concurrent Mark-Sweep Garbage Collector/并发标记清除垃圾收集器）垃圾收集器"></a>CMS（Concurrent Mark-Sweep Garbage Collector/并发标记清除垃圾收集器）垃圾收集器</h4><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117155836.png" alt="CMS（Concurrent Mark-Sweep Garbage Collector/并发标记清除垃圾收集器）垃圾收集器"></p>
<p><strong>初始标记：</strong></p>
<ul>
<li>STW，暂停所有工作线程</li>
<li>然后标记出GC Roots能直接可达的对象（不会去遍历所有可达对象）</li>
<li>一旦标记完成，就恢复工作线程继续执行</li>
<li>这个阶段耗时很短</li>
</ul>
<p><strong>并发标记：</strong></p>
<ul>
<li>从上一个阶段标记出的对象，开始遍历整个老年代，标出所有的可达对象</li>
<li>耗时会比较长</li>
<li>但是不需要STW，用户线程与垃圾收集线程一起执行</li>
<li><a href="#CMS垃圾收集器中的三色标记法"><font color="red">三色标记</font></a></li>
</ul>
<p><strong>重新标记：</strong></p>
<ul>
<li>上个阶段标记的对象，可能有误差，需要进行修正</li>
<li>需要STW，但是时间不是很长</li>
<li><a href="#CMS垃圾收集器中的增量更新"><font color="red">增量更新</font></a></li>
</ul>
<p><strong>并发清除：</strong></p>
<ul>
<li>删除垃圾对象</li>
<li>由于不需要移动对象，这个阶段也可以和用户线程一起执行，不需要STW</li>
</ul>
<p><strong>并发重置：</strong></p>
<ul>
<li>CMS 在进行垃圾收集时，会为每个对象分配一部分标记位图或者其他相关数据来追踪它们的状态（如是否被标记为垃圾）。在垃圾收集结束后，这些数据需要被清空或重置，以便在下一次垃圾收集时重新使用。</li>
<li>和其他 CMS 阶段一样，并发重置是一个并发操作，意味着它是在应用线程和垃圾收集线程同时执行的过程中进行的。这就避免了停顿时间对应用的影响，尽量减少了系统响应的延迟。</li>
<li>除了重置标记数据结构，CMS 还会在这个阶段释放一些与垃圾收集相关的资源，像内存和对象引用等。这有助于减少内存泄漏或资源浪费。</li>
<li>虽然并发重置阶段是在应用线程和垃圾收集线程并行执行的情况下进行的，但为了避免与应用线程产生竞争，CMS 设计了锁和协调机制来保证数据一致性。</li>
</ul>
<p>如果在并发标记、并发清理过程中，由于用户线程同时在执行，如果有新对象要进入老年代，但是空间又不够，那么就会导致”concurrent mode failure”,此时就会利用Serial Old来做一次垃圾收集，就会做一次全局的STW。<br>在并发清理过程中，可能产生新的垃圾，这些就是“浮动垃圾”，只能等到下一次GC时来清理。<br>由于采用的时标记-清除，所以会产生内存碎片，可以通过参数<code>-XX:+UseCMSCompactAtFullCollection</code>可以让JVM在执行完标记清除后再做一次整理，也可以通过<code>-XX:CMSFullGCsBeforeCompaction</code>来指定多少次GC后来做整理，默认是0，表示每次GC后都整理。</p>
<h5 id="CMS垃圾收集器中的三色标记法"><a href="#CMS垃圾收集器中的三色标记法" class="headerlink" title="CMS垃圾收集器中的三色标记法"></a>CMS垃圾收集器中的三色标记法</h5><p><strong>CMS垃圾收集器中的三色标记法</strong>是一种在垃圾收集中广泛使用的对象标记算法，用于解决垃圾回收中的对象存活性问题。三色标记法通过将堆中的对象分为三种颜色（白、灰、黑）来表示对象的不同状态，逐步完成对垃圾对象的识别和清理。</p>
<h6 id="三色标记的核心概念"><a href="#三色标记的核心概念" class="headerlink" title="三色标记的核心概念"></a><strong>三色标记的核心概念</strong></h6><ol>
<li><p><strong>白色</strong>：</p>
<ul>
<li>表示<strong>尚未访问到</strong>的对象。</li>
<li>在标记开始时，所有对象初始状态为白色。如果某个对象在垃圾收集完成时仍然是白色，则认为该对象是不可达的垃圾，后续会被清理。</li>
</ul>
</li>
<li><p><strong>灰色</strong>：</p>
<ul>
<li>表示<strong>已经被访问到，但其引用的对象尚未完全扫描</strong>的对象。</li>
<li>灰色对象是下一步需要处理的对象，其引用的其他对象需要继续递归检查。</li>
</ul>
</li>
<li><p><strong>黑色</strong>：</p>
<ul>
<li>表示<strong>已经被访问到且其引用的对象也都被标记完成</strong>的对象。</li>
<li>黑色对象是可达的，并且已经完全处理，无需再扫描。</li>
</ul>
</li>
</ol>
<h6 id="三色标记算法的工作流程"><a href="#三色标记算法的工作流程" class="headerlink" title="三色标记算法的工作流程"></a><strong>三色标记算法的工作流程</strong></h6><ol>
<li><strong>初始阶段</strong>（标记根对象）：</li>
</ol>
<ul>
<li>垃圾收集器首先从根集合（GC Root，例如静态变量、线程栈上的局部变量等）开始扫描，把所有可以直接到达的对象标记为灰色，并将它们加入扫描队列。</li>
<li>此时堆中的对象被分为两部分：<ul>
<li><strong>灰色对象</strong>：被标记为需要进一步处理的对象。</li>
<li><strong>白色对象</strong>：尚未被扫描的对象。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>扫描阶段</strong>（灰色对象处理）：</li>
</ol>
<ul>
<li>从灰色对象队列中取出一个对象，将其标记为黑色。</li>
<li>遍历该对象的所有引用，将其引用的白色对象标记为灰色，并将这些灰色对象加入扫描队列。</li>
<li>这个过程不断重复，直到所有灰色对象都被扫描完毕。</li>
</ul>
<ol start="3">
<li><strong>清理阶段</strong>：</li>
</ol>
<ul>
<li>当所有对象都被标记为黑色（可达）或白色（不可达）时，垃圾收集器会清理所有白色对象（即不可达的垃圾对象）。</li>
</ul>
<h6 id="三色标记法的优点"><a href="#三色标记法的优点" class="headerlink" title="三色标记法的优点"></a><strong>三色标记法的优点</strong></h6><ol>
<li><p><strong>并发性强</strong>：</p>
<ul>
<li>三色标记法允许垃圾收集器和应用线程并发运行，因为它能够分阶段处理对象。</li>
</ul>
</li>
<li><p><strong>分阶段标记</strong>：</p>
<ul>
<li>通过灰色对象队列分阶段标记，减少一次性标记的负担，有助于降低 STW（Stop-the-World）停顿时间。</li>
</ul>
</li>
<li><p><strong>明确区分状态</strong>：</p>
<ul>
<li>对象的状态被严格定义为白、灰、黑三种状态，简化了标记过程的逻辑。</li>
</ul>
</li>
</ol>
<h6 id="三色标记法的潜在问题"><a href="#三色标记法的潜在问题" class="headerlink" title="三色标记法的潜在问题"></a><strong>三色标记法的潜在问题</strong></h6><ol>
<li><strong>浮动垃圾</strong>（Floating Garbage）：</li>
</ol>
<ul>
<li><strong>问题描述</strong>：在并发标记的过程中，应用线程可能会修改对象的引用关系。例如，某个对象原本是垃圾，但在标记完成前被重新引用，垃圾收集器无法及时感知，导致下一次垃圾收集时才会清理这些对象。</li>
<li><strong>原因</strong>：并发标记过程中，垃圾收集器无法追踪到应用线程的动态变化。</li>
</ul>
<ol start="2">
<li><strong>误回收（对象丢失）</strong>：</li>
</ol>
<ul>
<li><strong>问题描述</strong>：在标记过程中，如果某些对象从一个灰色对象的引用链中被移出，垃圾收集器可能会错误地将这些对象标记为白色并回收。</li>
<li><strong>解决办法</strong>：<ul>
<li><strong>增量更新（Incremental Update）</strong>：当黑色对象的引用发生变化（新增指向白色对象的引用）时，及时将白色对象标记为灰色。</li>
<li><strong>快照清除（Snapshot-At-The-Beginning, SATB）</strong>：在标记开始时冻结对象图（即创建快照），任何对象的引用变化都不会影响本次垃圾收集。</li>
</ul>
</li>
</ul>
<h6 id="三色标记在-CMS-中的应用"><a href="#三色标记在-CMS-中的应用" class="headerlink" title="三色标记在 CMS 中的应用"></a><strong>三色标记在 CMS 中的应用</strong></h6><p>在 CMS 垃圾收集中，三色标记法被用于<strong>并发标记阶段</strong>来标记存活的对象，具体实现方式如下：</p>
<ol>
<li><p><strong>初始标记阶段（STW）</strong>：</p>
<ul>
<li>从 GC Root 开始标记，将直接可达的对象标记为灰色并暂停应用线程。</li>
</ul>
</li>
<li><p><strong>并发标记阶段</strong>：</p>
<ul>
<li>应用线程和垃圾收集线程同时运行，垃圾收集器递归处理灰色对象，将其引用的对象标记为灰色或黑色。</li>
</ul>
</li>
<li><p><strong>重新标记阶段（STW）</strong>：</p>
<ul>
<li>为了修正并发标记阶段遗漏的变化，垃圾收集器会再次暂停应用线程并完成一次快速的全局扫描。</li>
</ul>
</li>
<li><p><strong>清理阶段</strong>：</p>
<ul>
<li>并发清理所有白色对象，释放内存。</li>
</ul>
</li>
</ol>
<h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h6><p>三色标记法是垃圾回收算法的重要理论基础，通过分阶段处理对象引用关系，能够有效标记出存活对象，并减少停顿时间。然而，它在并发场景下需要解决<strong>浮动垃圾</strong>和<strong>误回收</strong>问题，这些问题通过增量更新和快照清除技术可以得到缓解。CMS 垃圾收集器利用三色标记法，实现了高效、低延迟的垃圾收集机制，是 JVM 垃圾收集技术中的重要里程碑。</p>
<h5 id="CMS垃圾收集器中的增量更新"><a href="#CMS垃圾收集器中的增量更新" class="headerlink" title="CMS垃圾收集器中的增量更新"></a>CMS垃圾收集器中的增量更新</h5><p><strong>CMS垃圾收集器中的增量更新</strong>（Incremental Update）是解决三色标记法并发标记阶段可能导致的<strong>对象丢失问题</strong>（漏标可达对象）的一种技术手段。</p>
<h6 id="为什么需要增量更新？"><a href="#为什么需要增量更新？" class="headerlink" title="为什么需要增量更新？"></a>为什么需要增量更新？</h6><p>在三色标记法中，垃圾收集器将对象分为白色（未标记对象）、灰色（待处理对象）和黑色（已处理对象）。并发标记阶段应用线程和垃圾收集线程同时运行，可能会出现以下问题：</p>
<ol>
<li><p><strong>对象丢失问题（漏标可达对象）：</strong></p>
<ul>
<li>在垃圾收集器标记过程中，如果某个<strong>黑色对象</strong>引用了一个<strong>白色对象</strong>，而这条引用关系是由应用线程新增的，垃圾收集器可能无法检测到，从而导致白色对象未被标记并被错误回收。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li>初始状态：<ul>
<li>A 是黑色对象（已标记完成）。</li>
<li>B 是灰色对象（正在处理）。</li>
<li>C 是白色对象（未标记）。</li>
</ul>
</li>
<li>应用线程运行时新增了引用关系 <code>A → C</code>。</li>
<li>垃圾收集器处理完成 B 后未检查到 A 的新增引用关系，导致 C 仍然是白色，并最终被错误回收。</li>
</ul>
</li>
</ol>
<h6 id="增量更新的基本思想"><a href="#增量更新的基本思想" class="headerlink" title="增量更新的基本思想"></a>增量更新的基本思想</h6><p>增量更新通过实时追踪<strong>新创建的引用关系</strong>来解决上述问题，确保白色对象在并发标记阶段能够被正确标记为灰色。其核心机制包括以下两部分：</p>
<ol>
<li><p><strong>黑色对象的引用关系更新：</strong></p>
<ul>
<li>如果在并发标记阶段，某个黑色对象新增了一条指向白色对象的引用（即 <code>A → C</code>），垃圾收集器会将白色对象立即标记为灰色对象，并加入到灰色队列中。</li>
</ul>
</li>
<li><p><strong>监控引用变化：</strong></p>
<ul>
<li>JVM 使用<strong>写屏障（Write Barrier）</strong>技术，在应用线程对引用关系进行修改时触发回调，通知垃圾收集器进行相应的标记更新。</li>
</ul>
</li>
</ol>
<h6 id="增量更新的实现机制"><a href="#增量更新的实现机制" class="headerlink" title="增量更新的实现机制"></a><strong>增量更新的实现机制</strong></h6><ol>
<li>写屏障的引入</li>
</ol>
<ul>
<li>写屏障是一种内存访问的钩子机制，可以监控对象引用关系的变化。</li>
<li>在 CMS 中，当应用线程新增引用（或修改引用）时，会触发写屏障操作，将目标对象（例如白色对象）加入灰色队列。</li>
</ul>
<ol start="2">
<li><p>增量更新的流程</p>
<ul>
<li><strong>步骤1</strong>：在并发标记阶段，CMS 垃圾收集器跟踪应用线程的引用变化。</li>
<li><strong>步骤2</strong>：当某个线程新增引用时，写屏障将目标白色对象标记为灰色对象。</li>
<li><strong>步骤3</strong>：灰色对象被重新加入标记队列，等待垃圾收集器完成后续扫描。</li>
</ul>
</li>
<li><p>增量更新的伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写屏障伪代码</span></span><br><span class="line"><span class="keyword">if</span> (更新引用) &#123;</span><br><span class="line">    <span class="keyword">if</span> (目标对象 == 白色) &#123;</span><br><span class="line">        将目标对象标记为灰色;</span><br><span class="line">        将目标对象加入灰色队列;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="增量更新的优点"><a href="#增量更新的优点" class="headerlink" title="增量更新的优点"></a>增量更新的优点</h6><ol>
<li><p><strong>解决对象丢失问题：</strong></p>
<ul>
<li>增量更新确保新增的引用关系能够被及时标记，避免垃圾收集器错误回收可达对象。</li>
</ul>
</li>
<li><p><strong>减少 Stop-The-World（STW）时间：</strong></p>
<ul>
<li>增量更新的实时追踪特性允许垃圾收集器和应用线程并发运行，从而降低垃圾回收对应用的影响。</li>
</ul>
</li>
<li><p><strong>与三色标记法的结合：</strong></p>
<ul>
<li>增量更新与三色标记法互补，可以提升并发垃圾收集的准确性和效率。</li>
</ul>
</li>
</ol>
<h6 id="增量更新的缺点和局限性"><a href="#增量更新的缺点和局限性" class="headerlink" title="增量更新的缺点和局限性"></a>增量更新的缺点和局限性</h6><ol>
<li><p><strong>性能开销：</strong></p>
<ul>
<li>写屏障需要监控每次引用关系的修改，这可能会增加额外的性能开销，尤其是在频繁更新引用的大型应用中。</li>
</ul>
</li>
<li><p><strong>实现复杂度高：</strong></p>
<ul>
<li>写屏障的实现需要深度集成到 JVM 的对象管理和垃圾收集逻辑中，对系统的兼容性和稳定性提出更高要求。</li>
</ul>
</li>
<li><p><strong>无法避免浮动垃圾：</strong></p>
<ul>
<li>增量更新主要解决对象丢失问题，但对于并发清理阶段遗留的浮动垃圾（Floating Garbage），仍然无能为力。</li>
</ul>
</li>
</ol>
<h6 id="增量更新-vs-快照清除"><a href="#增量更新-vs-快照清除" class="headerlink" title="增量更新 vs 快照清除"></a>增量更新 vs 快照清除</h6><p>增量更新和快照清除（SATB，Snapshot-At-The-Beginning）是两种解决并发标记问题的技术，二者的对比如下：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>增量更新</strong></th>
<th><strong>快照清除</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要问题</strong></td>
<td>对象丢失（漏标）</td>
<td>浮动垃圾（过时引用）</td>
</tr>
<tr>
<td><strong>基本思想</strong></td>
<td>跟踪引用变化并更新标记状态</td>
<td>冻结对象图，标记快照中的存活对象</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>写屏障增加额外开销</td>
<td>保持对象快照增加内存开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>对引用变化较频繁的应用效果更好</td>
<td>对引用变化较少的应用效果更好</td>
</tr>
</tbody></table>
<h6 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h6><p>增量更新是 CMS 垃圾收集器的一项关键技术，用于解决三色标记法中可能出现的对象丢失问题。它通过写屏障机制实时追踪引用关系变化，并将新增引用的白色对象标记为灰色，从而保证垃圾收集器的准确性。虽然增量更新会带来一定的性能开销，但它有效提升了垃圾回收的并发能力和程序的响应速度，是现代 JVM 垃圾收集技术中的重要组成部分。</p>
<h4 id="G1（Garbage-First）"><a href="#G1（Garbage-First）" class="headerlink" title="G1（Garbage-First）"></a>G1（Garbage-First）</h4><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117164552.png" alt="G1内存模型"><br>每一个方块叫做region，堆内存会分为2048个region，每个region的大小等于堆内存除以2048。<br>还是分了Eden区、S0区、S1区、老年代，只不过空间可以是不连续的了。<br><strong>Humongous</strong>区是专门用来存放大对象的（如果一个对象大小超过了一个region的50%，那么就是大对象）</p>
<h5 id="G1工作流程"><a href="#G1工作流程" class="headerlink" title="G1工作流程"></a>G1工作流程</h5><p><img data-src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20241117164956.png" alt="G1工作流程"></p>
<p><strong>初始标记（同CMS初始标记阶段）：</strong></p>
<ul>
<li>STW，暂停所有工作线程</li>
<li>然后标记出GC Roots能直接可达的对象（不会去遍历所有可达对象）</li>
<li>一旦标记完成，就恢复工作线程继续执行</li>
<li>这个阶段耗时很短</li>
</ul>
<p><strong>并发标记（同CMS并发标记阶段）：</strong></p>
<ul>
<li>从上一个阶段标记出的对象，开始遍历整个老年代，标出所有的可达对象</li>
<li>耗时会比较长</li>
<li>但是不需要STW，用户线程与垃圾收集线程一起执行</li>
<li><a href="#CMS垃圾收集器中的三色标记法"><font color="red">三色标记</font></a></li>
</ul>
<p><strong>最终标记（同CMS的重新标记）：</strong></p>
<ul>
<li>上个阶段标记的对象，可能有误差，需要进行修正</li>
<li>需要STW，但是时间不是很长</li>
<li>原始快照（CMS为增量更新）</li>
</ul>
<p><strong>筛选回收（类似CMS的并发清除阶段）：</strong></p>
<ul>
<li>需要STW，来清除垃圾对象</li>
<li>可以同-XX:MaxGCPauseMillis来指定GC的STW停顿时间，所以可能并不会回收掉所有的垃圾对象（根据内部算法排序，判断region中的垃圾，垃圾越多的越先清理），默认200ms</li>
<li>采用的复制算法，不会产生碎片（会把某个region里的垃圾对象复制到另外空闲的region区域，比如相邻的）</li>
</ul>
<h5 id="G1的垃圾回收类型"><a href="#G1的垃圾回收类型" class="headerlink" title="G1的垃圾回收类型"></a>G1的垃圾回收类型</h5><p><strong>Young GC：</strong> Eden区满，就会出发G1的Young GC，对Eden区进行GC<br><strong>Mixed GC：</strong> 老年代的占用率达到了-XX:InitiatingHeapOccupancyPercent指定的百分比，回收所有的新生代以及部分的老年代，以及大对象区<br><strong>Full GC：</strong> 在进行Mixed GC过程中，采用的复制算法，如果复制过程中内存不够，则会出发Full GC，会STW，并采用单线程来进行标记整理算法进行GC，相当于用一次Serial GC</p>
<h4 id="G1和CMS收集器的区别"><a href="#G1和CMS收集器的区别" class="headerlink" title="G1和CMS收集器的区别"></a>G1和CMS收集器的区别</h4><h5 id="CMS-是怎么工作的？"><a href="#CMS-是怎么工作的？" class="headerlink" title="CMS 是怎么工作的？"></a><strong>CMS 是怎么工作的？</strong></h5><p>CMS的垃圾回收器像一个清点员，在标记盒子的时候如果发现有人往白色盒子里放东西，它会立刻记录下来（增量更新），然后重新检查这个盒子，确保不会误扔。</p>
<p>这种方式的优点是：</p>
<ul>
<li>确保不会漏掉任何新增的引用。</li>
</ul>
<p>但缺点是：</p>
<ul>
<li>每次有人往盒子里放东西，清点员都要停下来记一下，会影响工作效率。<h5 id="G1是怎么工作的？"><a href="#G1是怎么工作的？" class="headerlink" title="G1是怎么工作的？"></a><strong>G1是怎么工作的？</strong></h5>G1 的垃圾回收器比较聪明，它不需要每次有人往盒子里放东西就停下来记录。它会在清点盒子的时候做个“快照”：</li>
<li>假装这个房间从标记开始的那一刻就静止了，不管后面有没有人动过盒子，它只清点快照里的盒子。</li>
<li>如果有人往白色盒子里放了东西，它会假设这些东西早就存在，并把那个盒子列入需要重新检查的范围。</li>
</ul>
<p><strong>这种方式的优点是：</strong></p>
<ul>
<li>清点员不用频繁停下来记录变化，效率更高。</li>
</ul>
<p><strong>缺点是：</strong></p>
<ul>
<li>需要多维护一些额外的信息（快照）。</li>
</ul>
<h5 id="为什么G1不用增量更新？"><a href="#为什么G1不用增量更新？" class="headerlink" title="为什么G1不用增量更新？"></a>为什么G1不用增量更新？</h5><p>因为 G1 的设计决定了它不需要像 CMS 那样实时跟踪盒子的变化。它通过“快照”的方式，提前把所有有可能存活的盒子都列入灰色或者黑色，这样新增的东西自然也不会被漏掉。<br>而CMS没有这种快照机制，只能靠增量更新来动态追踪变化.</p>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><ul>
<li>CMS 需要增量更新，因为它是实时清点，需要随时跟踪盒子的变化。</li>
<li>G1 不需要增量更新，因为它用“快照”代替了实时跟踪，把所有可能的变化都包含进去了。</li>
</ul>
<p>所以，G1 和 CMS 选择了不同的方式来解决问题，各有优缺点，但最终目的是一样的：安全地回收垃圾，确保程序正常运行。</p>
<h1 id="放在最后"><a href="#放在最后" class="headerlink" title="放在最后"></a>放在最后</h1><p>本文根据学习B站<a href="https://www.bilibili.com/video/BV1he4y1e7nW?spm_id_from=333.788.player.switch&vd_source=b4dd1b2b51d9d2f835b3eacde5ee0956&p=3" target="_blank" rel="noopener"><font color="0099ff">【JVM极简教程】2小时快速学会JVM，史上用时最短，效率最高！</font></a>整理笔记，有需要的同学可以前去系统的学习。</p>

    </div>
    <!-- 文章结束表示语-->
    <!-- 如果不是摘录 -->
      
        <div>
            <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">如果文章有问题可以在评论区留言，博客使用Gitalk实现的评论系统，登录后评论我的回复您将会收到Github的邮件提示<br/>当然也可以扫我的微信二维码添加我为好友和我一起沟通在开发中的问题，微信二维码在"菜单栏-联系我"中。<br/>希望大家一起，共同学习，共同成长。</div>
    
</div>

        </div>
      


    
    
    
        <div class="reward-container">
  <div><font color="red">您的支持将鼓励我继续创作！</font></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    赞赏支持
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/image-20200422204000194.png" alt="悟空 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/image-20200422204017953.png" alt="悟空 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/%E6%95%88%E7%8E%87%E5%AD%A6%E4%BC%9AJVM/" rel="tag"># 效率学会JVM</a>
          </div>
          <!-- bsShare分享-->
          <!-- 
          <br/>
          <div class="bshare-custom icon-medium"><a title="分享到QQ好友" class="bshare-qqim"></a><a title="分享到QQ空间" class="bshare-qzone"></a><a title="分享到微信" class="bshare-weixin"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a><span class="BSHARE_COUNT bshare-share-count">0</span></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/button.js#style=-1&amp;uuid=b92f7440-610c-4617-935f-53bc28fe72cb&amp;pophcol=2&amp;lang=zh"></script><a class="bshareDiv" onclick="javascript:return false;"></a><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>
          -->
        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/netty/BIO%E3%80%81NIO%E3%80%81AIO%E5%88%86%E6%9E%90.html" rel="prev" title="BIO、NIO、AIO对比分析">
      <i class="fa fa-chevron-left"></i> BIO、NIO、AIO对比分析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM整体结构"><span class="nav-number">1.</span> <span class="nav-text">JVM整体结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字节码的作用是什么？为什么需要字节码？"><span class="nav-number">2.</span> <span class="nav-text">字节码的作用是什么？为什么需要字节码？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类加载子系统是什么？如何工作的？"><span class="nav-number">3.</span> <span class="nav-text">类加载子系统是什么？如何工作的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链接"><span class="nav-number">3.1.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">3.1.1.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">3.1.2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">3.1.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">3.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">3.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引导类加载器"><span class="nav-number">3.3.1.</span> <span class="nav-text">引导类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK自定义加载器-继承实现ClassLoader类"><span class="nav-number">3.3.2.</span> <span class="nav-text">JDK自定义加载器(继承实现ClassLoader类)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器分类的总结"><span class="nav-number">3.3.3.</span> <span class="nav-text">类加载器分类的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派"><span class="nav-number">3.3.4.</span> <span class="nav-text">双亲委派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat为什么要自定义类加载器"><span class="nav-number">3.3.5.</span> <span class="nav-text">Tomcat为什么要自定义类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义类加载器的使用场景"><span class="nav-number">3.3.6.</span> <span class="nav-text">自定义类加载器的使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运行时数据区"><span class="nav-number">4.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器"><span class="nav-number">4.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟机栈（Java栈、Java方法栈）"><span class="nav-number">4.2.</span> <span class="nav-text">虚拟机栈（Java栈、Java方法栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量表"><span class="nav-number">4.2.1.</span> <span class="nav-text">局部变量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作数栈"><span class="nav-number">4.2.2.</span> <span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态链接"><span class="nav-number">4.2.3.</span> <span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法返回地址"><span class="nav-number">4.2.4.</span> <span class="nav-text">方法返回地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地方法栈"><span class="nav-number">4.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆"><span class="nav-number">4.4.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新生代"><span class="nav-number">4.4.1.</span> <span class="nav-text">新生代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Eden和S0、S1"><span class="nav-number">4.4.2.</span> <span class="nav-text">Eden和S0、S1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆内对象的生命周期"><span class="nav-number">4.4.3.</span> <span class="nav-text">堆内对象的生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#执行引擎"><span class="nav-number">5.</span> <span class="nav-text">执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解释器"><span class="nav-number">5.1.</span> <span class="nav-text">解释器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-中的解释器详解"><span class="nav-number">5.1.1.</span> <span class="nav-text">JVM 中的解释器详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释器的核心功能"><span class="nav-number">5.1.2.</span> <span class="nav-text">解释器的核心功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-解释器的执行流程"><span class="nav-number">5.1.3.</span> <span class="nav-text">JVM 解释器的执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释器的优点与缺点"><span class="nav-number">5.1.4.</span> <span class="nav-text">解释器的优点与缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点："><span class="nav-number">5.1.4.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点："><span class="nav-number">5.1.4.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释器在-JVM-中的角色"><span class="nav-number">5.1.5.</span> <span class="nav-text">解释器在 JVM 中的角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-解释器的实现方式"><span class="nav-number">5.1.6.</span> <span class="nav-text">JVM 解释器的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-解释器的优化策略"><span class="nav-number">5.1.7.</span> <span class="nav-text">JVM 解释器的优化策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-解释器的实际应用场景"><span class="nav-number">5.1.8.</span> <span class="nav-text">JVM 解释器的实际应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">5.1.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JIT（Just-In-Time）编译器"><span class="nav-number">5.2.</span> <span class="nav-text">JIT（Just-In-Time）编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT-编译器概述"><span class="nav-number">5.2.1.</span> <span class="nav-text">JIT 编译器概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT-编译器的工作原理"><span class="nav-number">5.2.2.</span> <span class="nav-text">JIT 编译器的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT-编译器的优势"><span class="nav-number">5.2.3.</span> <span class="nav-text">JIT 编译器的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT-编译器的挑战"><span class="nav-number">5.2.4.</span> <span class="nav-text">JIT 编译器的挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT-编译器的优化技术"><span class="nav-number">5.2.5.</span> <span class="nav-text">JIT 编译器的优化技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">5.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收器"><span class="nav-number">5.3.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要进行垃圾回收"><span class="nav-number">5.3.1.</span> <span class="nav-text">为什么要进行垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾标记方法"><span class="nav-number">5.3.2.</span> <span class="nav-text">垃圾标记方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数法"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可达性分析法"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">可达性分析法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾对象回收算法"><span class="nav-number">5.3.3.</span> <span class="nav-text">垃圾对象回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标记清除算法（Mark-Sweep）算法"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">标记清除算法（Mark-Sweep）算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制（Copying）算法"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">复制（Copying）算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标记-整理（Mark-Compact）算法"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">标记-整理（Mark-Compact）算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标记清除、复制、标记整理三种算法对比"><span class="nav-number">5.3.3.4.</span> <span class="nav-text">标记清除、复制、标记整理三种算法对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-number">5.3.4.</span> <span class="nav-text">分代收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的垃圾收集器"><span class="nav-number">5.3.5.</span> <span class="nav-text">常见的垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-GC和Parallel-Old-GC"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">Parallel GC和Parallel Old GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS（Concurrent-Mark-Sweep-Garbage-Collector-并发标记清除垃圾收集器）垃圾收集器"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">CMS（Concurrent Mark-Sweep Garbage Collector&#x2F;并发标记清除垃圾收集器）垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS垃圾收集器中的三色标记法"><span class="nav-number">5.3.5.2.1.</span> <span class="nav-text">CMS垃圾收集器中的三色标记法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#三色标记的核心概念"><span class="nav-number">5.3.5.2.1.1.</span> <span class="nav-text">三色标记的核心概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#三色标记算法的工作流程"><span class="nav-number">5.3.5.2.1.2.</span> <span class="nav-text">三色标记算法的工作流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#三色标记法的优点"><span class="nav-number">5.3.5.2.1.3.</span> <span class="nav-text">三色标记法的优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#三色标记法的潜在问题"><span class="nav-number">5.3.5.2.1.4.</span> <span class="nav-text">三色标记法的潜在问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#三色标记在-CMS-中的应用"><span class="nav-number">5.3.5.2.1.5.</span> <span class="nav-text">三色标记在 CMS 中的应用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#总结-2"><span class="nav-number">5.3.5.2.1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS垃圾收集器中的增量更新"><span class="nav-number">5.3.5.2.2.</span> <span class="nav-text">CMS垃圾收集器中的增量更新</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#为什么需要增量更新？"><span class="nav-number">5.3.5.2.2.1.</span> <span class="nav-text">为什么需要增量更新？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增量更新的基本思想"><span class="nav-number">5.3.5.2.2.2.</span> <span class="nav-text">增量更新的基本思想</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增量更新的实现机制"><span class="nav-number">5.3.5.2.2.3.</span> <span class="nav-text">增量更新的实现机制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增量更新的优点"><span class="nav-number">5.3.5.2.2.4.</span> <span class="nav-text">增量更新的优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增量更新的缺点和局限性"><span class="nav-number">5.3.5.2.2.5.</span> <span class="nav-text">增量更新的缺点和局限性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增量更新-vs-快照清除"><span class="nav-number">5.3.5.2.2.6.</span> <span class="nav-text">增量更新 vs 快照清除</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#总结-3"><span class="nav-number">5.3.5.2.2.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1（Garbage-First）"><span class="nav-number">5.3.5.3.</span> <span class="nav-text">G1（Garbage-First）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#G1工作流程"><span class="nav-number">5.3.5.3.1.</span> <span class="nav-text">G1工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1的垃圾回收类型"><span class="nav-number">5.3.5.3.2.</span> <span class="nav-text">G1的垃圾回收类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1和CMS收集器的区别"><span class="nav-number">5.3.5.4.</span> <span class="nav-text">G1和CMS收集器的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS-是怎么工作的？"><span class="nav-number">5.3.5.4.1.</span> <span class="nav-text">CMS 是怎么工作的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1是怎么工作的？"><span class="nav-number">5.3.5.4.2.</span> <span class="nav-text">G1是怎么工作的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么G1不用增量更新？"><span class="nav-number">5.3.5.4.3.</span> <span class="nav-text">为什么G1不用增量更新？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结-4"><span class="nav-number">5.3.5.4.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#放在最后"><span class="nav-number">6.</span> <span class="nav-text">放在最后</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="悟空"
      src="https://oss-wukong.oss-cn-chengdu.aliyuncs.com/img/20201124192552.jpeg">
  <p class="site-author-name" itemprop="name">悟空</p>
  <div class="site-description" itemprop="description">学得越多会得越少</div>
  <span class="site-location" itemprop="location"><i class="fa fa-map-marker"></i>&nbsp;重庆 · 九龙坡</span>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=296954345" title="QQ → tencent:&#x2F;&#x2F;AddContact&#x2F;?fromId&#x3D;50&amp;fromSubId&#x3D;1&amp;subcmd&#x3D;all&amp;uin&#x3D;296954345" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:296954345@qq.com" title="E-Mail → mailto:296954345@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/EdisonChenWuKong_admin" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;EdisonChenWuKong_admin" rel="noopener" target="_blank"><i class="fa fa-github fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/306267096" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;306267096" rel="noopener" target="_blank"><i class="fa fa-youtube-play fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <!-- 注释原有桃心
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  -->
  <span class="author" itemprop="copyrightHolder">悟空</span>


    <span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow" />
    <!-- 备案号 --><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">渝ICP备20003439号-1 </a>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">103k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:34</span>
</div>

<!-- 个人增值信息 -->
  <div class="theme-info">
  如果你的能力已经跟不上你的野心，那么就静下心来学习 --学无止境
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="\lib\fancybox\source\jquery.min.js"></script>
  <script src="\lib\fancybox\source\jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '504f849365841e0546ad',
      clientSecret: 'adc04143494fdb979267ebbd509543fc877f3a54',
      repo        : 'WuKong918-cn.github.io',
      owner       : 'WuKong918-cn',
      admin       : ['WuKong918-cn'],
      id          : '9cb36db2f77f4c7d839c198ad219dbeb',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

  <!-- 动态背景-->
  
</body>
</html>
